name: Base Deployment Workflow

on:
  workflow_call:
    inputs:
      environment:
        description: 'Deployment environment (prod or stage)'
        required: true
        type: string
      target_branch:
        description: 'Branch to deploy'
        required: true
        type: string
      k8s_context:
        description: 'Kubernetes context to use'
        required: true
        type: string
      k8s_namespace:
        description: 'Kubernetes namespace to deploy to'
        required: true
        type: string
      google_redirect_url:
        description: 'Google OAuth redirect URL'
        required: true
        type: string
    secrets:
      DOCKER_USERNAME:
        required: true
      DOCKER_TOKEN:
        required: true
      DB_ROOT_PASSWORD:
        required: true
      REDIS_PASSWORD:
        required: true
      POLYGON_API_KEY:
        required: true
      GEMINI_FREE_KEYS:
        required: true
      GOOGLE_CLIENT_ID:
        required: true
      GOOGLE_CLIENT_SECRET:
        required: true
      JWT_SECRET:
        required: true
      GITHUB_TOKEN:
        required: true

# Add permissions configuration here
permissions:
  contents: read
  packages: write
  id-token: write

# Update concurrency control to cancel in-progress jobs
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  # Add a dependency on the lint-and-build workflow for PR events
  check-build:
    runs-on: ubuntu-latest  # Using GitHub-hosted runner
    if: github.event_name == 'pull_request'
    steps:
      - name: Check if lint-and-build workflow passed
        run: echo "This job ensures the lint-and-build workflow has passed before deployment"

  deploy:
    runs-on: self-hosted  # Keep deployment on self-hosted runner
    needs: [check-build]
    if: >-
      (github.event_name != 'pull_request' || success())
    # Add job-level permissions to ensure access to secrets
    
    # Add environment variables for the job
    env:
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_TOKEN: ${{ secrets.DOCKER_TOKEN }}
      DB_ROOT_PASSWORD: ${{ secrets.DB_ROOT_PASSWORD }}
      REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
      POLYGON_API_KEY: ${{ secrets.POLYGON_API_KEY }}
      GEMINI_FREE_KEYS: ${{ secrets.GEMINI_FREE_KEYS }}
      GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
      GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
      JWT_SECRET: ${{ secrets.JWT_SECRET }}
      GOOGLE_REDIRECT_URL: ${{ inputs.google_redirect_url }}
      K8S_CONTEXT: ${{ inputs.k8s_context }}
      K8S_NAMESPACE: ${{ inputs.k8s_namespace }}
      ENVIRONMENT: ${{ inputs.environment }}
    
    steps:
      # Print debugging information before checkout
      - name: Debug Event Information
        run: |
          echo "Event name: ${{ github.event_name }}"
          echo "GitHub ref: ${{ github.ref }}"
          echo "Target branch: ${{ github.base_ref || github.ref_name }}"
          echo "Environment: ${{ inputs.environment }}"

      # Determine which branch to checkout based on event type
      - name: Set checkout target
        id: set-target
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "CHECKOUT_REF=${{ github.head_ref }}" >> $GITHUB_ENV
            echo "TARGET_BRANCH=${{ github.base_ref }}" >> $GITHUB_ENV
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.branch }}" ]; then
            echo "CHECKOUT_REF=${{ github.event.inputs.branch }}" >> $GITHUB_ENV
            echo "TARGET_BRANCH=${{ github.event.inputs.branch }}" >> $GITHUB_ENV
          else
            echo "CHECKOUT_REF=${{ inputs.target_branch }}" >> $GITHUB_ENV
            echo "TARGET_BRANCH=${{ inputs.target_branch }}" >> $GITHUB_ENV
          fi

      - name: Checkout code
        uses: actions/checkout@v3
        with:
          ref: ${{ env.CHECKOUT_REF }}
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 1
          lfs: false
      
      # Add diagnostic step to see what's available after checkout
      - name: Show Git Information
        run: |
          echo "Current directory: $(pwd)"
          echo "Directory contents: $(ls -la)"
          echo "Git status: $(git status)"
          echo "Current branch: $(git branch --show-current)"
          git --version
      
      # Verify secrets are available without exposing them
      - name: Verify Docker Credentials
        run: |
          echo "Docker username secret: $(if [ -n "${{ secrets.DOCKER_USERNAME }}" ]; then echo "is set"; else echo "is NOT set"; fi)"
          echo "Docker token secret: $(if [ -n "${{ secrets.DOCKER_TOKEN }}" ]; then echo "is set"; else echo "is NOT set"; fi)"
          echo "DB password secret: $(if [ -n "${{ secrets.DB_ROOT_PASSWORD }}" ]; then echo "is set"; else echo "is NOT set"; fi)"
          echo "Polygon API key: $(if [ -n "${{ secrets.POLYGON_API_KEY }}" ]; then echo "is set"; else echo "is NOT set"; fi)"
          echo "Gemini keys: $(if [ -n "${{ secrets.GEMINI_FREE_KEYS }}" ]; then echo "is set"; else echo "is NOT set"; fi)"
          echo "Google OAuth credentials: $(if [ -n "${{ secrets.GOOGLE_CLIENT_ID }}" ] && [ -n "${{ secrets.GOOGLE_CLIENT_SECRET }}" ]; then echo "are set"; else echo "are NOT set"; fi)"
      
      # Run the deployment steps using the scripts
      - name: Setup deployment
        run: |
          # Load env-specific configuration
          source .github/scripts/deployment/load-env-config.sh "${{ inputs.environment }}"
          
          # Make deployment scripts executable
          chmod +x .github/scripts/deployment/*.sh
          
          # Log function for better readability
          log() {
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
          }
          
          # Sanitize branch name for Docker tags (replace / with - and other invalid characters)
          DOCKER_TAG=$(echo "${{ env.TARGET_BRANCH }}" | sed 's/\//-/g' | sed 's/[^a-zA-Z0-9_.-]/-/g')
          echo "DOCKER_TAG=${DOCKER_TAG}" >> $GITHUB_ENV
          
          log "Using Docker tag: ${DOCKER_TAG}"
          log "Starting deployment process for branch: ${{ env.TARGET_BRANCH }}..."

      # Build Docker images
      - name: Build Docker Images
        run: |
          .github/scripts/deployment/build-images.sh "${{ env.DOCKER_TAG }}" "${{ env.TARGET_BRANCH }}"

      # Push Docker images
      - name: Login to Docker Hub and Push Images
        run: |
          .github/scripts/deployment/push-images.sh "${{ env.DOCKER_TAG }}" "${{ env.TARGET_BRANCH }}"

      # Setup Kubernetes context
      - name: Setup Kubernetes Context
        run: |
          .github/scripts/deployment/setup-k8s.sh "${{ inputs.k8s_context }}" "${{ inputs.k8s_namespace }}"

      # Check and ensure PVCs are bound
      - name: Verify PersistentVolumeClaims
        run: |
          .github/scripts/deployment/verify-pvcs.sh "${{ inputs.environment }}"

      # Update Kubernetes secrets
      - name: Update Kubernetes Secrets
        run: |
          .github/scripts/deployment/update-secrets.sh

      # Run database migrations
      - name: Deploy Database Migrations
        run: |
          .github/scripts/deployment/run-migrations.sh

      # Deploy to Kubernetes
      - name: Deploy to Kubernetes
        run: |
          .github/scripts/deployment/deploy-to-k8s.sh "${{ env.DOCKER_TAG }}" "${{ inputs.environment }}"
      
      # Cleanup after deployment
      - name: Cleanup
        if: always()  # Run cleanup even if previous steps failed
        run: |
          .github/scripts/deployment/cleanup.sh 