# DISABLED: Using k8s-deploy.yml instead
# To re-enable, remove the "if: false" condition below

name: Deploy to Production

on:
  push:
    branches:
      - prod  # Trigger on pushes to the prod branch
  pull_request:
    branches:
      - prod  # Trigger on pull requests to the prod branch

jobs:
  deploy:
    if: false  # This prevents the workflow from running
    runs-on: ubuntu-latest
    environment: prod
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # Print debug info about secrets (masked in logs)
      - name: Debug secrets
        run: |
          echo "Checking if REMOTE_HOST secret exists: ${{ secrets.REMOTE_HOST != '' }}"
          echo "Checking if REMOTE_USER secret exists: ${{ secrets.REMOTE_USER != '' }}"
          echo "Checking if SSH_PRIVATE_KEY secret exists: ${{ secrets.SSH_PRIVATE_KEY != '' }}"
          echo "Checking if DOCKERHUB_USERNAME secret exists: ${{ secrets.DOCKERHUB_USERNAME != '' }}"
          echo "Checking if DOCKERHUB_TOKEN secret exists: ${{ secrets.DOCKERHUB_TOKEN != '' }}"
          echo "Checking if CLOUDFLARE_CERT secret exists: ${{ secrets.CLOUDFLARE_CERT != '' }}"

      # Install Cloudflared
      - name: Install Cloudflared
        run: |
          # Download and install cloudflared
          curl -L --output cloudflared.deb https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared.deb
          cloudflared version

      # Use ssh-agent for improved key management
      - name: Set up SSH key using ssh-agent
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      
      # Set up Cloudflare access and SSH config
      - name: Configure Cloudflare Access
        env:
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          CLOUDFLARE_CERT: ${{ secrets.CLOUDFLARE_CERT }}
        run: |
          # Validate that required secrets are not empty
          if [ -z "$REMOTE_HOST" ]; then
            echo "ERROR: REMOTE_HOST is empty or not set"
            exit 1
          fi
          
          if [ -z "$REMOTE_USER" ]; then
            echo "ERROR: REMOTE_USER is empty or not set"
            exit 1
          fi
          
          if [ -z "$CLOUDFLARE_CERT" ]; then
            echo "ERROR: CLOUDFLARE_CERT is empty or not set"
            exit 1
          fi
          
          # Set up Cloudflare certificate
          mkdir -p ~/.cloudflared
          echo "$CLOUDFLARE_CERT" > ~/.cloudflared/cert.pem
          chmod 600 ~/.cloudflared/cert.pem
          
          # Create SSH config properly
          mkdir -p ~/.ssh
          
          echo "Host $REMOTE_HOST" > ~/.ssh/config
          echo "    ProxyCommand cloudflared access ssh --hostname %h" >> ~/.ssh/config
          echo "    User $REMOTE_USER" >> ~/.ssh/config
          echo "    StrictHostKeyChecking no" >> ~/.ssh/config
          echo "    UserKnownHostsFile /dev/null" >> ~/.ssh/config
          echo "    ServerAliveInterval 60" >> ~/.ssh/config
          echo "    ConnectTimeout 30" >> ~/.ssh/config
          echo "    KexAlgorithms +diffie-hellman-group1-sha1,diffie-hellman-group14-sha1" >> ~/.ssh/config
          echo "    PubkeyAcceptedAlgorithms +ssh-rsa" >> ~/.ssh/config
          echo "    HostkeyAlgorithms +ssh-rsa" >> ~/.ssh/config
          
          chmod 600 ~/.ssh/config
          
          # Display SSH config for debugging
          echo "SSH config created:"
          cat ~/.ssh/config
          
          # Verify cloudflared can connect
          echo "Testing cloudflared connection..."
          cloudflared access ssh-config --hostname $REMOTE_HOST || echo "Cloudflared access ssh-config failed"

      # Deploy using Cloudflare SSH command
      - name: Deploy to production server
        env:
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          # Test SSH connection with public key information
          echo "Testing SSH connection..."
          ssh-add -L
          echo "Testing connection with SSH key auth..."
          ssh -v "$REMOTE_HOST" "echo SSH connection successful" || {
            echo "SSH key authentication failed, check if the public key is in the server's ~/.ssh/authorized_keys file"
            exit 1
          }
          
          # Now run the deployment commands
          ssh "$REMOTE_HOST" '
            cd /home/aj/dev/study
            git checkout prod
            git pull origin prod
            
            # Set up environment for Docker login
            echo "Attempting Docker login on remote server..."
            
            # Login to Docker Hub with verbose output
            echo "Running Docker login command..."
            docker login docker.io -u "'$DOCKERHUB_USERNAME'" -p "'$DOCKERHUB_TOKEN'" || {
              echo "Docker login failed with exit code $?"
              echo "Docker login error details:"
              docker info
              exit 1
            }
            echo "Docker login successful!"
            
            # Build and push images directly on the server
            echo "Building and pushing Docker images..."
            
            # Backend
            echo "Building backend image..."
            docker build -t "'$DOCKERHUB_USERNAME'"/backend:latest -f ./backend/Dockerfile.prod ./backend
            echo "Pushing backend image..."
            docker push "'$DOCKERHUB_USERNAME'"/backend:latest
            
            # Frontend
            echo "Building frontend image..."
            docker build -t "'$DOCKERHUB_USERNAME'"/frontend:latest -f ./frontend/Dockerfile.prod ./frontend
            echo "Pushing frontend image..."
            docker push "'$DOCKERHUB_USERNAME'"/frontend:latest
            
            # Database
            echo "Building database image..."
            docker build -t "'$DOCKERHUB_USERNAME'"/db:latest -f ./db/Dockerfile.prod ./db
            echo "Pushing database image..."
            docker push "'$DOCKERHUB_USERNAME'"/db:latest
            
            # Worker
            echo "Building worker image..."
            docker build -t "'$DOCKERHUB_USERNAME'"/worker:latest -f ./worker/Dockerfile ./worker
            echo "Pushing worker image..."
            docker push "'$DOCKERHUB_USERNAME'"/worker:latest
            
            # TF
            echo "Building tf image..."
            docker build -t "'$DOCKERHUB_USERNAME'"/tf:latest -f ./tf/Dockerfile ./tf
            echo "Pushing tf image..."
            docker push "'$DOCKERHUB_USERNAME'"/tf:latest
            
            # Cache
            echo "Building cache image..."
            docker build -t "'$DOCKERHUB_USERNAME'"/cache:latest -f ./cache/Dockerfile ./cache
            echo "Pushing cache image..."
            docker push "'$DOCKERHUB_USERNAME'"/cache:latest
            
            # Nginx
            echo "Building nginx image..."
            docker build -t "'$DOCKERHUB_USERNAME'"/nginx:latest -f ./nginx/Dockerfile ./nginx
            echo "Pushing nginx image..."
            docker push "'$DOCKERHUB_USERNAME'"/nginx:latest
            
            # Apply Kubernetes configurations
            echo "Applying Kubernetes configurations..."
            cd prod
            kubectl apply -f config/
            
            # Perform rolling updates
            echo "Performing rolling updates..."
            kubectl rollout restart deployment/backend
            kubectl rollout restart deployment/frontend
            kubectl rollout restart deployment/worker
            kubectl rollout restart deployment/tf
            kubectl rollout restart deployment/db
            kubectl rollout restart deployment/cache
            kubectl rollout restart deployment/nginx
          ' 