name: Lint and Build Check
on:
  pull_request:
    branches: [main, prod]

  # Only trigger on direct pushes to ben/aj branches that are not associated with PRs
  push:
    branches: [ben, aj]
    paths-ignore:
      - '.github/workflows/**'  # Avoid triggering workflow changes twice
    # Add condition to exclude PR-related pushes
    tags-ignore:
      - '**'  # Ignore tag pushes

  # Add workflow_run trigger to run after branch-protection workflow
  workflow_run:
    workflows: ["Branch Protection Check"]
    types:
      - completed

# Add concurrency to cancel in-progress jobs when a new commit is pushed
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

env:
  # Linting configuration
  GOLANGCI_LINT_VERSION: v2.3.0
  PYTHON_VERSION: '3.11'  # Using system Python 3.11 from Debian 12 for self-hosted runners
  NODE_VERSION: '18'

jobs:
  # determine-runner-user job removed â€“ containers now run as root by default

  # Add a check to determine if we should run the tests
  check-workflow-conditions:
    runs-on: self-hosted
    permissions:
      actions: read
      contents: read
      pull-requests: read
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
      continue_on_error: ${{ steps.check.outputs.continue_on_error }}
      last_success_sha: ${{ steps.get-last-success.outputs.sha }}
      has_backend_changes: ${{ steps.changed-paths.outputs.has_backend_changes }}
      has_frontend_changes: ${{ steps.changed-paths.outputs.has_frontend_changes }}
      has_worker_changes: ${{ steps.changed-paths.outputs.has_worker_changes }}
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - id: check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Check if this is a push on a branch that has an open PR
          if [[ "${{ github.event_name }}" == "push" ]]; then
            BRANCH_NAME="${{ github.ref_name }}"
            echo "Current branch: $BRANCH_NAME"

            PR_COUNT=$(gh api graphql -f query='
              query($owner:String!, $repo:String!, $headRef:String!) {
                repository(owner:$owner, name:$repo) {
                  pullRequests(headRefName:$headRef, states:OPEN) {
                    totalCount
                  }
                }
              }' -f owner="${{ github.repository_owner }}" -f repo="${{ github.event.repository.name }}" -f headRef="$BRANCH_NAME" --jq '.data.repository.pullRequests.totalCount')

            if [[ $PR_COUNT -gt 0 ]]; then
              echo "This push is on a branch with an open PR - skipping duplicate run"
              echo "should_run=false" >> $GITHUB_OUTPUT
              echo "continue_on_error=false" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          if [[ "${{ github.event_name }}" == "push" && ("${{ github.ref }}" == "refs/heads/ben" || "${{ github.ref }}" == "refs/heads/aj") ]]; then
            echo "Running for push to ben/aj branch - will not fail on errors"
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "continue_on_error=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [[ "${{ github.event_name }}" == "pull_request" && "${{ github.base_ref }}" == "main" ]]; then
            echo "Running for PR to main branch"
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "continue_on_error=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [[ ("${{ github.event_name }}" == "pull_request" && "${{ github.base_ref }}" == "prod") || \
                ("${{ github.event_name }}" == "workflow_run" && "${{ github.event.workflow_run.head_branch }}" == "prod") ]]; then
            echo "Skipping lint and build for prod deployment"
            echo "should_run=false" >> $GITHUB_OUTPUT
            echo "continue_on_error=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            if [[ "${{ github.event.workflow_run.conclusion }}" == "success" ]]; then
              echo "Branch protection check passed, proceeding with tests"
              echo "should_run=true" >> $GITHUB_OUTPUT
              echo "continue_on_error=false" >> $GITHUB_OUTPUT
            else
              echo "Branch protection check did not pass, skipping tests"
              echo "should_run=false" >> $GITHUB_OUTPUT
              echo "continue_on_error=false" >> $GITHUB_OUTPUT
            fi
            exit 0
          fi

          echo "Running tests by default"
          echo "should_run=true" >> $GITHUB_OUTPUT
          echo "continue_on_error=false" >> $GITHUB_OUTPUT

      - id: get-last-success
        if: steps.check.outputs.should_run == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "sha=0000000000000000000000000000000000000000" >> $GITHUB_OUTPUT # Default to initial commit

          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "sha=${{ github.event.pull_request.base.sha }}" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Getting last successful workflow run SHA..."
          WORKFLOW_FILENAME="lint-and-build.yml" # Assuming this is the current workflow's filename
          BRANCH_NAME="${{ github.ref_name }}"

          LAST_RUN_ID=$(gh api \
            -H "Accept: application/vnd.github+json" \
            "/repos/${{ github.repository }}/actions/workflows/$WORKFLOW_FILENAME/runs?branch=$BRANCH_NAME&status=success&per_page=1" \
            --jq '.workflow_runs[0].id')

          if [ -n "$LAST_RUN_ID" ] && [ "$LAST_RUN_ID" != "null" ]; then
            echo "Found last successful run: $LAST_RUN_ID"
            LAST_SUCCESS_SHA=$(gh api \
              -H "Accept: application/vnd.github+json" \
              "/repos/${{ github.repository }}/actions/runs/$LAST_RUN_ID" \
              --jq '.head_sha')

            if [ -n "$LAST_SUCCESS_SHA" ] && [ "$LAST_SUCCESS_SHA" != "null" ]; then
              echo "Last successful commit SHA: $LAST_SUCCESS_SHA"
              echo "sha=$LAST_SUCCESS_SHA" >> $GITHUB_OUTPUT
            else
              echo "Using previous commit as fallback (could not get SHA from last run)"
              echo "sha=$(git rev-parse HEAD~1 || git rev-parse HEAD)" >> $GITHUB_OUTPUT # Fallback to HEAD if no HEAD~1
            fi
          else
            echo "No previous successful run found, using previous commit as fallback"
            echo "sha=$(git rev-parse HEAD~1 || git rev-parse HEAD)" >> $GITHUB_OUTPUT # Fallback to HEAD if no HEAD~1
          fi

      - name: Check for backend/frontend changes
        id: changed-paths
        if: steps.check.outputs.should_run == 'true'
        run: |
          BASE_SHA="${{ steps.get-last-success.outputs.sha }}"
          # Ensure BASE_SHA is a valid commit, otherwise default to comparing against initial state (all changes)
          if ! git cat-file -e $BASE_SHA 2>/dev/null; then
            echo "Warning: BASE_SHA ($BASE_SHA) is not a valid commit. Diffing against initial commit."
            # Get the initial commit of the current branch or the repository
            INITIAL_COMMIT=$(git rev-list --max-parents=0 HEAD)
            BASE_SHA=$INITIAL_COMMIT
          fi
          HEAD_SHA=$(git rev-parse HEAD)

          echo "Comparing changes for backend/frontend between $BASE_SHA and $HEAD_SHA"

          # Check backend
          # Use git diff --name-only and then check if output is non-empty
          BACKEND_CHANGES=$(git diff --name-only $BASE_SHA $HEAD_SHA -- 'services/backend/')
          if [ -z "$BACKEND_CHANGES" ]; then
            echo "No changes in backend."
            echo "has_backend_changes=false" >> $GITHUB_OUTPUT
          else
            echo "Changes detected in backend."
            echo "has_backend_changes=true" >> $GITHUB_OUTPUT
          fi

          # Check frontend
          FRONTEND_CHANGES=$(git diff --name-only $BASE_SHA $HEAD_SHA -- 'services/frontend/')
          if [ -z "$FRONTEND_CHANGES" ]; then
            echo "No changes in frontend."
            echo "has_frontend_changes=false" >> $GITHUB_OUTPUT
          else
            echo "Changes detected in frontend."
            echo "has_frontend_changes=true" >> $GITHUB_OUTPUT
          fi

          # Check worker
          WORKER_CHANGES=$(git diff --name-only $BASE_SHA $HEAD_SHA -- 'services/worker/')
          if [ -z "$WORKER_CHANGES" ]; then
            echo "No changes in worker."
            echo "has_worker_changes=false" >> $GITHUB_OUTPUT
          else
            echo "Changes detected in worker."
            echo "has_worker_changes=true" >> $GITHUB_OUTPUT
          fi

  # Go Format Check (from format.yaml)
  # format-go:
  #   name: Go Format Check (camelCase enforcement)
  #   needs: [check-workflow-conditions]
  #   if: ${{ always() && needs.check-workflow-conditions.outputs.should_run == 'true' && needs.check-workflow-conditions.outputs.has_backend_changes == 'true' }}
  #   runs-on: ubuntu-latest
  #   timeout-minutes: 10
  #   continue-on-error: ${{ needs.check-workflow-conditions.outputs.continue_on_error == 'true' }}
  #   
  #   steps:
  #     - name: ðŸ”§ Checkout code
  #       uses: actions/checkout@v4

  #     - name: ðŸ¹ Setup Go
  #       uses: actions/setup-go@v5
  #       with:
  #         go-version: stable
  #         cache: true
  #         cache-dependency-path: services/backend/go.sum

  #     - name: ðŸ” Go format check (camelCase enforcement)
  #       uses: golangci/golangci-lint-action@v8
  #       with:
  #         version: ${{ env.GOLANGCI_LINT_VERSION }}
  #         working-directory: services/backend
  #         args: >-
  #           --timeout=5m
  #           --config .golangci.yml
  #           ./...
  #           --no-fix

  #     - name: Create job summary for Go Format
  #       if: always()
  #       shell: bash
  #       run: |
  #         if [[ "${{ job.status }}" == "success" || ("${{ job.status }}" == "failure" && "${{ needs.check-workflow-conditions.outputs.continue_on_error }}" == "true") ]]; then
  #           echo "### Go Format Check Results âœ…" >> $GITHUB_STEP_SUMMARY
  #           echo "âœ… Go format checks completed with camelCase enforcement." >> $GITHUB_STEP_SUMMARY
  #         elif [[ "${{ job.status }}" == "skipped" ]]; then
  #           echo "### Go Format Check Results âž¡ï¸" >> $GITHUB_STEP_SUMMARY
  #           echo "âž¡ï¸ Go format checks skipped as no changes were detected in 'services/backend/'." >> $GITHUB_STEP_SUMMARY
  #         else
  #           echo "### Go Format Check Results âŒ" >> $GITHUB_STEP_SUMMARY
  #           echo "âŒ Go format checks failed (see logs for details)." >> $GITHUB_STEP_SUMMARY
  #         fi

  # Python Format Check (from format.yaml)
  # format-python:
  #   name: Python Format Check (camelCase enforcement)
  #   needs: [check-workflow-conditions]
  #   if: ${{ always() && needs.check-workflow-conditions.outputs.should_run == 'true' && needs.check-workflow-conditions.outputs.has_worker_changes == 'true' }}
  #   runs-on: ubuntu-latest
  #   timeout-minutes: 10
  #   continue-on-error: ${{ needs.check-workflow-conditions.outputs.continue_on_error == 'true' }}
  #   
  #   steps:
  #     - name: ðŸ”§ Checkout code
  #       uses: actions/checkout@v4

  #     - name: ðŸ Setup Python
  #       uses: actions/setup-python@v4
  #       with:
  #         python-version: ${{ env.PYTHON_VERSION }}
  #         cache: 'pip'
  #         cache-dependency-path: services/worker/requirements.txt

  #     - name: ðŸ“¦ Install Python dependencies
  #       run: |
  #         cd services/worker
  #         pip install -r requirements.txt
  #         cd ../..

  #     - name: ðŸ” Run Pylint with camelCase enforcement (check only)
  #       run: |
  #         echo "ðŸ” Running Python linting with camelCase enforcement (check only)..."
  #         pylint services/worker/ --rcfile=services/worker/.pylintrc --output-format=text

  #     - name: Create job summary for Python Format
  #       if: always()
  #       shell: bash
  #       run: |
  #         if [[ "${{ job.status }}" == "success" || ("${{ job.status }}" == "failure" && "${{ needs.check-workflow-conditions.outputs.continue_on_error }}" == "true") ]]; then
  #           echo "### Python Format Check Results âœ…" >> $GITHUB_STEP_SUMMARY
  #           echo "âœ… Python format checks completed with camelCase enforcement." >> $GITHUB_STEP_SUMMARY
  #         elif [[ "${{ job.status }}" == "skipped" ]]; then
  #           echo "### Python Format Check Results âž¡ï¸" >> $GITHUB_STEP_SUMMARY
  #           echo "âž¡ï¸ Python format checks skipped as no changes were detected in 'services/worker/'." >> $GITHUB_STEP_SUMMARY
  #         else
  #           echo "### Python Format Check Results âŒ" >> $GITHUB_STEP_SUMMARY
  #           echo "âŒ Python format checks failed (see logs for details)." >> $GITHUB_STEP_SUMMARY
  #         fi

  # Svelte/TypeScript/JavaScript Format Check (from format.yaml)
  # format-svelte:
  #   name: Svelte/TS/JS Format Check (camelCase enforcement)
  #   needs: [check-workflow-conditions]
  #   if: ${{ always() && needs.check-workflow-conditions.outputs.should_run == 'true' && needs.check-workflow-conditions.outputs.has_frontend_changes == 'true' }}
  #   runs-on: ubuntu-latest
  #   timeout-minutes: 15
  #   continue-on-error: ${{ needs.check-workflow-conditions.outputs.continue_on_error == 'true' }}
  #   
  #   steps:
  #     - name: ðŸ”§ Checkout code
  #       uses: actions/checkout@v4

  #     - name: ðŸŸ¢ Setup Node.js
  #       uses: actions/setup-node@v4
  #       with:
  #         node-version: ${{ env.NODE_VERSION }}
  #         cache: 'npm'
  #         cache-dependency-path: services/frontend/package-lock.json

  #     - name: ðŸ“¦ Install dependencies
  #       run: |
  #         echo "ðŸ“¦ Installing Node.js dependencies..."
  #         cd services/frontend
  #         # Temporarily rename root eslintrc to avoid dependency resolution conflicts
  #         mv ../../.eslintrc.js ../../.eslintrc.js.bak || true
  #         npm ci
  #         # Restore root eslintrc
  #         mv ../../.eslintrc.js.bak ../../.eslintrc.js || true
  #         cd ../..

  #     - name: ðŸ” Run ESLint with camelCase enforcement (check only)
  #       run: |
  #         echo "ðŸ” Running ESLint with camelCase enforcement (check only)..."
  #         cd services/frontend
  #         npx eslint --no-flat-config 'src/**/*.{js,ts,svelte}'

  #     - name: ðŸŽ¨ Run Stylelint with camelCase enforcement (check only)
  #       run: |
  #         echo "ðŸŽ¨ Running Stylelint with camelCase enforcement (check only)..."
  #         cd services/frontend
  #         npx stylelint 'src/**/*.{css,svelte}' --config .stylelintrc.json --no-fix

  #     - name: Create job summary for Svelte/TS/JS Format
  #       if: always()
  #       shell: bash
  #       run: |
  #         if [[ "${{ job.status }}" == "success" || ("${{ job.status }}" == "failure" && "${{ needs.check-workflow-conditions.outputs.continue_on_error }}" == "true") ]]; then
  #           echo "### Svelte/TS/JS Format Check Results âœ…" >> $GITHUB_STEP_SUMMARY
  #           echo "âœ… Svelte/TS/JS format checks completed with camelCase enforcement." >> $GITHUB_STEP_SUMMARY
  #         elif [[ "${{ job.status }}" == "skipped" ]]; then
  #           echo "### Svelte/TS/JS Format Check Results âž¡ï¸" >> $GITHUB_STEP_SUMMARY
  #           echo "âž¡ï¸ Svelte/TS/JS format checks skipped as no changes were detected in 'services/frontend/'." >> $GITHUB_STEP_SUMMARY
  #         else
  #           echo "### Svelte/TS/JS Format Check Results âŒ" >> $GITHUB_STEP_SUMMARY
  #           echo "âŒ Svelte/TS/JS format checks failed (see logs for details)." >> $GITHUB_STEP_SUMMARY
  #         fi

  # YAML Format Check (from format.yaml)
  # format-yaml:
  #   name: YAML Format Check
  #   needs: [check-workflow-conditions]
  #   if: ${{ always() && needs.check-workflow-conditions.outputs.should_run == 'true' }}
  #   runs-on: ubuntu-latest
  #   timeout-minutes: 5
  #   continue-on-error: ${{ needs.check-workflow-conditions.outputs.continue_on_error == 'true' }}
  #   
  #   steps:
  #     - name: ðŸ”§ Checkout code
  #       uses: actions/checkout@v4

  #     - name: ðŸ Setup Python
  #       uses: actions/setup-python@v4
  #       with:
  #         python-version: ${{ env.PYTHON_VERSION }}

  #     - name: ðŸ“¦ Install YAML tools
  #       run: |
  #         echo "ðŸ“¦ Installing YAML formatting tools..."
  #         pip install yamllint pyyaml

  #     - name: ðŸ” Run YAML lint (check only)
  #       run: |
  #         echo "ðŸ” Running YAML linting (check only)..."
  #         yamllint -c .yamllint .github/ config/ services/ --strict

  #     - name: Create job summary for YAML Format
  #       if: always()
  #       shell: bash
  #       run: |
  #         if [[ "${{ job.status }}" == "success" || ("${{ job.status }}" == "failure" && "${{ needs.check-workflow-conditions.outputs.continue_on_error }}" == "true") ]]; then
  #           echo "### YAML Format Check Results âœ…" >> $GITHUB_STEP_SUMMARY
  #           echo "âœ… YAML format checks completed." >> $GITHUB_STEP_SUMMARY
  #         else
  #           echo "### YAML Format Check Results âŒ" >> $GITHUB_STEP_SUMMARY
  #           echo "âŒ YAML format checks failed (see logs for details)." >> $GITHUB_STEP_SUMMARY
  #         fi

  # SQL Format Check (new addition)
  # format-sql:
  #   name: SQL Format Check (consistent formatting)
  #   needs: [check-workflow-conditions]
  #   if: ${{ always() && needs.check-workflow-conditions.outputs.should_run == 'true' }}
  #   runs-on: ubuntu-latest
  #   timeout-minutes: 10
  #   continue-on-error: ${{ needs.check-workflow-conditions.outputs.continue_on_error == 'true' }}
  #   
  #   steps:
  #     - name: ðŸ”§ Checkout code
  #       uses: actions/checkout@v4
  #
  #     - name: ðŸ Setup Python
  #       uses: actions/setup-python@v4
  #       with:
  #         python-version: ${{ env.PYTHON_VERSION }}
  #
  #     - name: ðŸ“¦ Install SQLFluff
  #       run: |
  #         echo "ðŸ“¦ Installing SQLFluff..."
  #         pip install sqlfluff
  #
  #     - name: ðŸ” Run SQLFluff with consistent formatting (check only)
  #       run: |
  #         echo "ðŸ” Running SQLFluff with consistent formatting (check only)..."
  #         sqlfluff lint --config services/db/.sqlfluff services/db/migrations/*.sql services/db/init/*.sql
  #
  #     - name: Create job summary for SQL Format
  #       if: always()
  #       shell: bash
  #       run: |
  #         if [[ "${{ job.status }}" == "success" || ("${{ needs.check-workflow-conditions.outputs.continue_on_error }}" == "true") ]]; then
  #           echo "### SQL Format Check Results âœ…" >> $GITHUB_STEP_SUMMARY
  #           echo "âœ… SQL format checks completed with consistent formatting." >> $GITHUB_STEP_SUMMARY
  #         else
  #           echo "### SQL Format Check Results âŒ" >> $GITHUB_STEP_SUMMARY
  #           echo "âŒ SQL format checks failed (see logs for details)." >> $GITHUB_STEP_SUMMARY
  #         fi

  backend-lint-security:
    needs: [check-workflow-conditions]
    if: ${{ always() && needs.check-workflow-conditions.outputs.should_run == 'true' && needs.check-workflow-conditions.outputs.has_backend_changes == 'true' }}
    container:
      image: billin19/ci-image:latest # Use custom Docker image
      # options: --user 0
    runs-on: self-hosted
    continue-on-error: ${{ needs.check-workflow-conditions.outputs.continue_on_error == 'true' }}
    permissions:
      contents: write
      checks: write
      pull-requests: read
    env:
      # Use a workspace-local GOPATH so the non-root UID can write to it
      GOPATH: ${{ github.workspace }}/.go
      GOMODCACHE: ${{ github.workspace }}/.go/pkg/mod
      GOCACHE: ${{ github.workspace }}/.go/cache
      GO111MODULE: "on"
    steps:
      - uses: actions/checkout@v3
        with:
          ref: ${{ github.event.workflow_run.head_branch || github.ref }}
          fetch-depth: 0

      - name: Mark the Git workspace as safe
        run: git config --global --add safe.directory "${GITHUB_WORKSPACE:-$(pwd)}"

      - name: Cache Go modules and build tools
        uses: actions/cache@v4
        with:
          path: |
            ${{ env.GOPATH }}/pkg/mod
            ${{ env.GOCACHE }}
            ~/.cache/golangci-lint # Cache for golangci-lint
            ${{ env.GOPATH }}/bin
          key: ${{ runner.os }}-go-${{ hashFiles('services/backend/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Enforce go mod tidy & verify
        working-directory: services/backend
        run: |
          go mod tidy
          go mod verify
          if ! git diff --quiet go.mod go.sum; then
            echo "::error file=services/backend/go.mod,title=go.mod/go.sum outdated::'go mod tidy' resulted in changes. Please run 'go mod tidy' locally and commit the changes."
            echo "Diff:"
            git diff --color=always go.mod go.sum # Adding color and specifying files for clarity
            exit 1
          else
            echo "go.mod and go.sum are already tidy."
          fi

      - name: Vet, Lint, Staticcheck, Gosec, Build
        working-directory: services/backend
        run: |
          echo "Cleaning Go caches..."
          go clean -cache || true
          go clean -modcache || true
          
          # Force cleanup with proper permissions if needed
          if [ -d "$GOMODCACHE" ]; then
            echo "Force cleaning module cache with proper permissions..."
            chmod -R u+w "$GOMODCACHE" || true
            rm -rf "$GOMODCACHE" || true
          fi
          if [ -d "$GOCACHE" ]; then
            echo "Force cleaning build cache with proper permissions..."
            chmod -R u+w "$GOCACHE" || true
            rm -rf "$GOCACHE" || true
          fi
          
          echo "Re-tidying modules..."
          go mod tidy
          echo "Running go vet..."
          go vet ./...

          echo "Running staticcheck..."
          staticcheck -tags=all ./...

          echo "Running gosec..." # Assuming gosec is in PATH in the container
          gosec -quiet -tags=all ./...

          echo "Running Go Build..."
          go build -v -tags=all ./...
        # continue-on-error for this combined step will be based on the job's continue-on-error

      - name: Go Lint with golangci-lint
        uses: golangci/golangci-lint-action@v8
        with:
          version: ${{ env.GOLANGCI_LINT_VERSION }}
          working-directory: services/backend
          args: >-
            --timeout=3m
            --config=.golangci.yml
            --max-issues-per-linter=10
            --max-same-issues=5
            --build-tags=all
            --allow-parallel-runners
            --path-prefix=services/backend
          # Disable PR diff fetching to avoid 20k line limit issues
          only-new-issues: false
          skip-cache: true
        env:
          GO111MODULE: "on"
        # continue-on-error for this specific action is handled by job's continue-on-error

      - name: ðŸ”’ Run Go vulnerability check
        working-directory: services/backend
        run: |
          echo "ðŸ”’ Running Go vulnerability scanning with govulncheck..."
          # Install govulncheck if not available
          go install golang.org/x/vuln/cmd/govulncheck@latest
          
          # Run vulnerability check
          govulncheck ./... || VULN_EXIT_CODE=$?
          
          if [ "$VULN_EXIT_CODE" != "0" ]; then
            echo "::error title=Go Security Vulnerabilities::Found security vulnerabilities in Go dependencies. Review the output above."
            if [[ "${{ needs.check-workflow-conditions.outputs.continue_on_error }}" != "true" ]]; then
              exit 1
            fi
          fi

      - name: Unit tests with race detector
        if: | # Only run for PRs to main, where continue_on_error is false
          github.event_name == 'pull_request' &&
          github.base_ref == 'main' &&
          needs.check-workflow-conditions.outputs.continue_on_error == 'false'
        working-directory: services/backend
        env:
          CGO_ENABLED: "1"
        run: |
          echo "Running go test -race..."
          go test -race -count=1 -tags=all ./...

      - name: Create job summary for Backend
        if: always() # Run even if previous steps failed, to provide a summary
        shell: bash
        run: |
          if [[ "${{ job.status }}" == "success" || ("${{ job.status }}" == "failure" && "${{ needs.check-workflow-conditions.outputs.continue_on_error }}" == "true") ]]; then
            echo "### Backend CI Results âœ…" >> $GITHUB_STEP_SUMMARY
            echo "âœ… Backend checks completed (lint, security, vulnerability scan - see logs for details)." >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ job.status }}" == "skipped" ]]; then
            echo "### Backend CI Results âž¡ï¸" >> $GITHUB_STEP_SUMMARY
            echo "âž¡ï¸ Backend checks skipped as no changes were detected in 'services/backend/'." >> $GITHUB_STEP_SUMMARY
          else
            echo "### Backend CI Results âŒ" >> $GITHUB_STEP_SUMMARY
            echo "âŒ Backend checks failed (lint, security, or vulnerability scan - see logs for details)." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Final Go cache cleanup
        if: always() # Always run to ensure cleanup even if other steps fail
        run: |
          echo "Performing final cleanup of Go caches..."
          # Force cleanup of Go module cache with proper permissions
          if [ -d "$GOMODCACHE" ]; then
            echo "Cleaning Go module cache at $GOMODCACHE"
            chmod -R u+w "$GOMODCACHE" || true
            rm -rf "$GOMODCACHE" || true
          fi
          if [ -d "$GOCACHE" ]; then
            echo "Cleaning Go build cache at $GOCACHE"
            chmod -R u+w "$GOCACHE" || true
            rm -rf "$GOCACHE" || true
          fi
          # Clean any remaining .go directory
          if [ -d "$GOPATH" ]; then
            echo "Cleaning remaining Go workspace at $GOPATH"
            chmod -R u+w "$GOPATH" || true
            rm -rf "$GOPATH" || true
          fi
          echo "Final Go cache cleanup complete."

  frontend-lint-security:
    needs: [check-workflow-conditions]
    if: ${{ always() && needs.check-workflow-conditions.outputs.should_run == 'true' && needs.check-workflow-conditions.outputs.has_frontend_changes == 'true' }}
    container:
      image: billin19/ci-image:latest # Use custom Docker image
      # options: --user 0
    runs-on: self-hosted
    continue-on-error: ${{ needs.check-workflow-conditions.outputs.continue_on_error == 'true' }}
    steps:
      - uses: actions/checkout@v3
        with:
          ref: ${{ github.event.workflow_run.head_branch || github.ref }}
          fetch-depth: 0

      - name: Cache npm packages
        uses: actions/cache@v4
        with:
          path: ~/.npm # Cache npm's global cache directory
          key: ${{ runner.os }}-npm-cache-${{ hashFiles('services/frontend/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-npm-cache-

      - name: Install frontend dependencies
        working-directory: services/frontend
        run: |
          # Clean install to avoid issues with cached/corrupted dependencies
          echo "Performing a clean install of npm packages..."
          rm -rf node_modules package-lock.json
          npm install

          # Using npm ci for reliable installs from package-lock.json
          # npm ci

          # Install packages required for Stylelint with Svelte
          echo "Installing PostCSS for Stylelint..."
          npm install --save-dev postcss postcss-html

          # Install additional test dependencies if not already in package.json as devDependencies
          echo "Ensuring testing libraries are available..."
          npm install --save-dev jest@29 @types/jest ts-jest@29 svelte-jester@2 @testing-library/svelte @testing-library/jest-dom jsdom

          # Check if jest.config.cjs already exists - if so, use the existing one
          if [ -f "jest.config.cjs" ]; then
            echo "Using existing Jest configuration file (jest.config.cjs)..."
          else
            echo "Creating Jest configuration file (jest.config.cjs)..."
            echo "/** @type {import('jest').Config} */" > jest.config.cjs
            echo "module.exports = {" >> jest.config.cjs
            echo "  preset: 'ts-jest'," >> jest.config.cjs
            echo "  testEnvironment: 'jsdom'," >> jest.config.cjs
            echo "  setupFilesAfterEnv: ['<rootDir>/jest.setup.cjs']," >> jest.config.cjs
            echo "  transform: {" >> jest.config.cjs
            echo "    '^.+\.svelte$': 'svelte-jester'," >> jest.config.cjs
            echo "    '^.+\.(ts|js)$': 'ts-jest'" >> jest.config.cjs
            echo "  }," >> jest.config.cjs
            echo "  moduleNameMapper: {" >> jest.config.cjs
            echo "    '^\$lib/(.*)$': '<rootDir>/src/lib/$1'" >> jest.config.cjs
            echo "  }," >> jest.config.cjs
            echo "  moduleFileExtensions: ['js', 'ts', 'svelte']" >> jest.config.cjs
            echo "};" >> jest.config.cjs
          fi

      - name: Create simplified Jest configuration and setup
        working-directory: services/frontend
        run: |
          echo "Ensuring Jest setup (jest.setup.cjs)..."
          # Check if jest.setup.cjs already exists - if so, use the existing one
          if [ -f "jest.setup.cjs" ]; then
            echo "Using existing Jest setup file (jest.setup.cjs)..."
          elif [ -f "jest.setup.js" ]; then # Original exists, cjs doesn't
            echo "Creating CommonJS version of jest.setup.js as jest.setup.cjs..."
            cp jest.setup.js jest.setup.js.original # Backup original
            echo "// CommonJS version of the Jest setup file (auto-converted)" > jest.setup.cjs
            echo "// Original file preserved as jest.setup.js.original" >> jest.setup.cjs
            echo "require('@testing-library/jest-dom');" >> jest.setup.cjs
          else # Neither cjs nor js exists for setup
             echo "// Jest setup file - CommonJS format" > jest.setup.cjs
             echo "require('@testing-library/jest-dom');" >> jest.setup.cjs
          fi

          # Create minimal SvelteKit type structure if it doesn't exist
          mkdir -p .svelte-kit/types
          if [ ! -f "src/app.d.ts" ]; then
            mkdir -p src
            echo "// Minimal type definitions for testing" > src/app.d.ts
            echo "declare global { namespace App {} }" >> src/app.d.ts
            echo "export {};" >> src/app.d.ts
          fi

      - name: Run SvelteKit sync
        working-directory: services/frontend
        run: |
          echo "Running SvelteKit sync to generate .svelte-kit directory and type definitions..."
          npx svelte-kit sync

      - name: ðŸ” Run ESLint
        working-directory: services/frontend
        run: |
          echo "ðŸ” Running ESLint..."
          npx eslint 'src/**/*.{js,ts,svelte}'

      - name: ðŸŽ¨ Run Stylelint
        working-directory: services/frontend
        run: |
          echo "ðŸŽ¨ Running Stylelint..."
          npx stylelint 'src/**/*.{css,svelte}' --config .stylelintrc.json --no-fix

      - name: ðŸ”’ Run npm audit for security vulnerabilities
        working-directory: services/frontend
        run: |
          echo "ðŸ”’ Running npm audit for security vulnerabilities..."
          # Run audit and capture exit code
          npm audit --audit-level=high --json > npm-audit-report.json || AUDIT_EXIT_CODE=$?
          
          # Display human-readable audit results
          echo "=== NPM Audit Results ==="
          npm audit --audit-level=high || true
          
          # Check if there are high or critical vulnerabilities
          if [ -f "npm-audit-report.json" ]; then
            HIGH_CRITICAL_COUNT=$(cat npm-audit-report.json | jq -r '.metadata.vulnerabilities.high + .metadata.vulnerabilities.critical' 2>/dev/null || echo "0")
            echo "High + Critical vulnerabilities found: $HIGH_CRITICAL_COUNT"
            
            if [ "$HIGH_CRITICAL_COUNT" != "0" ] && [ "$HIGH_CRITICAL_COUNT" != "null" ]; then
              echo "::error title=Security Vulnerabilities::Found $HIGH_CRITICAL_COUNT high or critical security vulnerabilities. Run 'npm audit fix' to resolve."
              if [[ "${{ needs.check-workflow-conditions.outputs.continue_on_error }}" != "true" ]]; then
                exit 1
              fi
            fi
          fi

      - name: Run frontend tests
        working-directory: services/frontend
        run: |
          echo "Running frontend tests with npm/npx..."
          # Assuming 'test' script in package.json runs jest, or run jest directly via npx
          npx jest --config jest.config.cjs # Explicitly use the cjs config
        # continue-on-error for this step is handled by job's continue-on-error

      - name: Create job summary for Frontend
        if: always()
        shell: bash
        run: |
          if [[ "${{ job.status }}" == "success" || ("${{ job.status }}" == "failure" && "${{ needs.check-workflow-conditions.outputs.continue_on_error }}" == "true") ]]; then
            echo "### Frontend CI Results âœ…" >> $GITHUB_STEP_SUMMARY
            echo "âœ… Frontend checks completed (lint, security, vulnerability scan - see logs for details)." >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ job.status }}" == "skipped" ]]; then
            echo "### Frontend CI Results âž¡ï¸" >> $GITHUB_STEP_SUMMARY
            echo "âž¡ï¸ Frontend checks skipped as no changes were detected in 'services/frontend/'." >> $GITHUB_STEP_SUMMARY
          else
            echo "### Frontend CI Results âŒ" >> $GITHUB_STEP_SUMMARY
            echo "âŒ Frontend checks failed (lint, security, or vulnerability scan - see logs for details)." >> $GITHUB_STEP_SUMMARY
          fi

  worker-lint-security:
    needs: [check-workflow-conditions]
    if: ${{ always() && needs.check-workflow-conditions.outputs.should_run == 'true' && needs.check-workflow-conditions.outputs.has_worker_changes == 'true' }}
    runs-on: self-hosted
    continue-on-error: ${{ needs.check-workflow-conditions.outputs.continue_on_error == 'true' }}
    permissions:
      contents: read
      checks: write
      security-events: write
    steps:
      - uses: actions/checkout@v3
        with:
          ref: ${{ github.event.workflow_run.head_branch || github.ref }}
          fetch-depth: 0

      # - name: Set up Python 3.11
      #   uses: actions/setup-python@v4
      #   with:
      #     python-version: '3.11'
      #     cache: 'pip'

      - name: Use system Python 3.11 (Debian 12 default)
        run: |
          echo "Using system Python instead of actions/setup-python for self-hosted runner"
          python3 --version
          python3 -m pip --version

      - name: Install dependencies
        working-directory: services/worker
        run: |
          # -----------------------------
          # OLD system-wide installation (now disabled because Debian 12 marks the
          # root environment as "externally-managed", see PEP 668). Keeping for
          # easy rollback:
          # python -m pip install --upgrade pip
          # pip install -r requirements.txt
          #
          # NEW: create an isolated virtual environment so we can safely install
          # anything we need without hitting the externally-managed restriction.
          # -----------------------------
          python3 -m venv .venv
          # Add the venv to PATH for the *rest of the job* so subsequent steps
          # pick up flake8, isort, mypy, etc. from the venv without having to
          # reference the full path each time.
          echo "$(pwd)/.venv/bin" >> "$GITHUB_PATH"

          # Upgrade pip inside venv and install deps
          .venv/bin/pip install --upgrade pip
          .venv/bin/pip install -r requirements.txt

      - name: Configure Python Path
        working-directory: services/worker
        run: |
          echo "Adding src directory to PYTHONPATH for this job"
          echo "PYTHONPATH=$(pwd)/src" >> $GITHUB_ENV

      - name: Import sorting check with isort
        working-directory: services/worker
        run: |
          echo "Checking import sorting with isort..."
          isort --check-only --diff . || true

      - name: Code style check with flake8
        working-directory: services/worker
        run: |
          echo "Running flake8 code style checks..."
          flake8 . || true

      - name: Static type checking with mypy
        working-directory: services/worker
        run: |
          echo "Running mypy static type checking..."
          mypy . || true  # Allow mypy to fail softly for now

      - name: Comprehensive linting with pylint
        working-directory: services/worker
        run: |
          echo "Running pylint comprehensive linting..."
          pylint src/ worker.py

      - name: Security linting with bandit
        working-directory: services/worker
        run: |
          echo "Running bandit security checks..."
          bandit -r . -f json -o bandit-report.json || true
          bandit -r . -f txt

      - name: Dependency vulnerability scanning with safety
        working-directory: services/worker
        run: |
          echo "Scanning dependencies for known vulnerabilities..."
          safety check --json --output safety-report.json || true
          safety check

      - name: Run tests with coverage
        working-directory: services/worker
        run: |
          echo "Running tests with coverage..."
          pytest --cov=src --cov-report=xml --cov-report=term-missing || true

      - name: Upload coverage to Codecov
        if: github.event_name == 'pull_request'
        uses: codecov/codecov-action@v3
        with:
          file: services/worker/coverage.xml
          flags: worker
          name: worker-coverage
          fail_ci_if_error: false

      - name: Create job summary for Worker
        if: always()
        shell: bash
        run: |
          if [[ "${{ job.status }}" == "success" || ("${{ job.status }}" == "failure" && "${{ needs.check-workflow-conditions.outputs.continue_on_error }}" == "true") ]]; then
            echo "### Worker CI Results âœ…" >> $GITHUB_STEP_SUMMARY
            echo "âœ… Worker lint and security checks completed (see logs for details)." >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ job.status }}" == "skipped" ]]; then
            echo "### Worker CI Results âž¡ï¸" >> $GITHUB_STEP_SUMMARY
            echo "âž¡ï¸ Worker checks skipped as no changes were detected in 'services/worker/'." >> $GITHUB_STEP_SUMMARY
          else
            echo "### Worker CI Results âŒ" >> $GITHUB_STEP_SUMMARY
            echo "âŒ Worker lint and security checks failed (see logs for details)." >> $GITHUB_STEP_SUMMARY
          fi

# Summary and reporting (updated to include format checks)
#  lint-summary:
#    name: Lint and Format Summary
#    runs-on: self-hosted
#    needs: [backend-lint-security, frontend-lint-security, worker-lint-security]
#    if: always()
#
#    steps:
#      - name: ðŸ“Š Generate Lint and Format Summary
#        run: |
#          echo "ðŸ“Š Lint and Format Summary Report"
#          echo "================================"
#          echo ""
#          echo "âœ… Go format checks completed with camelCase enforcement"
#          echo "âœ… Python format checks completed with camelCase enforcement"
#          echo "âœ… Svelte/TS/JS format checks completed"
#          echo "âœ… YAML format checks completed"
#          echo "âœ… SQL format checks completed with consistent formatting"
#          echo "âœ… Backend lint and security checks completed"
#          echo "âœ… Frontend lint and security checks completed"
#          echo "âœ… Worker lint and security checks completed"
#          echo ""
#          echo "ðŸŽ¯ Go format checks enforce camelCase; Python format checks enforce snake_case naming conventions"
#          echo "ðŸ“‹ SQL allows both snake_case and camelCase for consistency with existing code"
#          echo "ðŸ“‹ All linters run in CHECK-ONLY mode - no code modifications"
#          echo ""
#          echo "ðŸ“‹ Summary:"
#          echo "- Go: golangci-lint with revive rules for camelCase"
#          echo "- Python: Pylint with snake_case naming rules"
#          echo "- Svelte/TS/JS: ESLint + Stylelint"
#          echo "- YAML: yamllint for formatting consistency"
#          echo "- SQL: SQLFluff with consistent formatting"
#          echo "- Backend: Full security and lint checks"
#          echo "- Frontend: Full security and lint checks"
#          echo "- Worker: Full security and lint checks"

# Workspace permission reset (runs on host, not in container)
#  reset-workspace-permissions:
#    name: Reset workspace file ownership
#    runs-on: self-hosted
#    needs: [backend-lint-security, frontend-lint-security, worker-lint-security]
#    if: always()
#
#    steps:
#      - name: Change ownership of workspace back to runner user
#        run: |
#          echo "Resetting ownership of $GITHUB_WORKSPACE to $(id -u):$(id -g)..."
#          sudo chown -R $(id -u):$(id -g) "$GITHUB_WORKSPACE"
#          echo "Done."
