name: Deploy to Kubernetes

on:
  push:
    branches:
      - prod  # Trigger on pushes to the prod branch
  pull_request:
    branches:
      - prod  # Trigger on pull requests to the prod branch

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # Set up kubectl
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      # Set up kubeconfig directly from secret
      - name: Set up kubeconfig file
        run: |
          echo "${{ secrets.KUBE_CONFIG }}" > kubeconfig
          chmod 600 kubeconfig
          echo "KUBECONFIG=$(pwd)/kubeconfig" >> $GITHUB_ENV

      # Deploy to remote server - build and push Docker images directly on the server
      - name: Deploy to production server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.REMOTE_HOST }}
          username: ${{ secrets.REMOTE_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: 22
          debug: true
          script: |
            cd /home/aj/dev/study
            git checkout prod
            git pull origin prod
            
            # Generate a unique tag based on commit SHA
            SHA_TAG=$(git rev-parse --short HEAD)
            echo "Using image tag: $SHA_TAG"
            
            # Set up environment for Docker login
            echo "Attempting Docker login on remote server..."
            
            # Use DOCKERHUB credentials for consistency across workflows
            echo "Running Docker login command..."
            docker login docker.io -u "${{ secrets.DOCKERHUB_USERNAME }}" -p "${{ secrets.DOCKERHUB_TOKEN }}" || {
              echo "Docker login failed with exit code $?"
              echo "Docker login error details:"
              docker info
              exit 1
            }
            echo "Docker login successful!"
            
            # Build and push images directly on the server
            echo "Building and pushing Docker images with tag: $SHA_TAG"
            
            # Backend
            echo "Building backend image..."
            docker build -t "${{ secrets.DOCKERHUB_USERNAME }}/backend:latest" -t "${{ secrets.DOCKERHUB_USERNAME }}/backend:$SHA_TAG" -f ./backend/Dockerfile.prod ./backend
            echo "Pushing backend images..."
            docker push "${{ secrets.DOCKERHUB_USERNAME }}/backend:latest"
            docker push "${{ secrets.DOCKERHUB_USERNAME }}/backend:$SHA_TAG"
            
            # Frontend
            echo "Building frontend image..."
            docker build -t "${{ secrets.DOCKERHUB_USERNAME }}/frontend:latest" -t "${{ secrets.DOCKERHUB_USERNAME }}/frontend:$SHA_TAG" -f ./frontend/Dockerfile.prod ./frontend
            echo "Pushing frontend images..."
            docker push "${{ secrets.DOCKERHUB_USERNAME }}/frontend:latest"
            docker push "${{ secrets.DOCKERHUB_USERNAME }}/frontend:$SHA_TAG"
            
            # Worker
            echo "Building worker image..."
            docker build -t "${{ secrets.DOCKERHUB_USERNAME }}/worker:latest" -t "${{ secrets.DOCKERHUB_USERNAME }}/worker:$SHA_TAG" -f ./worker/Dockerfile ./worker
            echo "Pushing worker images..."
            docker push "${{ secrets.DOCKERHUB_USERNAME }}/worker:latest"
            docker push "${{ secrets.DOCKERHUB_USERNAME }}/worker:$SHA_TAG"
            
            # Update image tags in manifests
            echo "Updating image tags in Kubernetes manifests..."
            sed -i "s|image: ${{ secrets.DOCKERHUB_USERNAME }}/backend:latest|image: ${{ secrets.DOCKERHUB_USERNAME }}/backend:$SHA_TAG|g" prod/config/backend.yaml
            sed -i "s|image: ${{ secrets.DOCKERHUB_USERNAME }}/frontend:latest|image: ${{ secrets.DOCKERHUB_USERNAME }}/frontend:$SHA_TAG|g" prod/config/frontend.yaml
            sed -i "s|image: ${{ secrets.DOCKERHUB_USERNAME }}/worker:latest|image: ${{ secrets.DOCKERHUB_USERNAME }}/worker:$SHA_TAG|g" prod/config/worker.yaml
            
            # Apply Kubernetes manifests with zero downtime strategy
            echo "Applying Kubernetes manifests..."
            
            # Apply database changes first and wait for readiness
            echo "Applying database configuration..."
            kubectl apply -f prod/config/db.yaml
            kubectl rollout status statefulset/db --timeout=300s
            
            # Apply cache service
            echo "Applying cache configuration..."
            kubectl apply -f prod/config/cache.yaml
            kubectl rollout status deployment/cache --timeout=300s
            
            # Apply backend services
            echo "Applying backend configuration..."
            kubectl apply -f prod/config/backend.yaml
            kubectl rollout status deployment/backend --timeout=300s
            
            # Apply worker services
            echo "Applying worker configuration..."
            kubectl apply -f prod/config/worker.yaml
            kubectl rollout status deployment/worker --timeout=300s
            
            # Apply frontend last
            echo "Applying frontend configuration..."
            kubectl apply -f prod/config/frontend.yaml
            kubectl rollout status deployment/frontend --timeout=300s
            
            # Apply nginx configuration
            echo "Applying nginx configuration..."
            kubectl apply -f prod/config/nginx.yaml
            kubectl rollout status deployment/nginx --timeout=300s 