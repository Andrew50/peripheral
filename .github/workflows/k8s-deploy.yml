name: Deploy to Kubernetes

on:
  push:
    branches:
      - prod  # Trigger on pushes to the prod branch
  pull_request:
    branches:
      - prod  # Trigger on pull requests to the prod branch

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: prod
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # Set up kubectl
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      # Print debug info about secrets (masked in logs)
      - name: Debug secrets
        run: |
          echo "Checking if REMOTE_HOST secret exists: ${{ secrets.REMOTE_HOST != '' }}"
          echo "Checking if REMOTE_USER secret exists: ${{ secrets.REMOTE_USER != '' }}"
          echo "Checking if SSH_PRIVATE_KEY secret exists: ${{ secrets.SSH_PRIVATE_KEY != '' }}"
          echo "Checking if DOCKERHUB_USERNAME secret exists: ${{ secrets.DOCKERHUB_USERNAME != '' }}"
          echo "Checking if DOCKERHUB_TOKEN secret exists: ${{ secrets.DOCKERHUB_TOKEN != '' }}"
          echo "Checking if CLOUDFLARE_CERT secret exists: ${{ secrets.CLOUDFLARE_CERT != '' }}"

      # Install Cloudflared
      - name: Install Cloudflared
        run: |
          # Download and install cloudflared
          curl -L --output cloudflared.deb https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared.deb
          cloudflared version

      # Set up SSH key and Cloudflare tunnel configuration
      - name: Set up SSH key
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          CLOUDFLARE_CERT: ${{ secrets.CLOUDFLARE_CERT }}
        run: |
          # Set default values if secrets are not defined
          if [ -z "$REMOTE_HOST" ]; then
            echo "REMOTE_HOST not defined in secrets, using default value"
            REMOTE_HOST="ssh.atlantis.trading"
          fi
          
          if [ -z "$REMOTE_USER" ]; then
            echo "REMOTE_USER not defined in secrets, using default value"
            REMOTE_USER="aj"
          fi
          
          # Validate that required secrets are not empty
          if [ -z "$SSH_PRIVATE_KEY" ]; then
            echo "ERROR: SSH_PRIVATE_KEY is empty or not set"
            exit 1
          fi
          
          if [ -z "$CLOUDFLARE_CERT" ]; then
            echo "ERROR: CLOUDFLARE_CERT is empty or not set"
            exit 1
          fi
          
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Set up Cloudflare certificate
          mkdir -p ~/.cloudflared
          echo "$CLOUDFLARE_CERT" > ~/.cloudflared/cert.pem
          chmod 600 ~/.cloudflared/cert.pem
          
          # Create SSH config script to avoid YAML indentation issues
          echo '#!/bin/bash' > create_ssh_config.sh
          echo "echo \"Host $REMOTE_HOST\" > ~/.ssh/config" >> create_ssh_config.sh
          echo "echo \"    ProxyCommand cloudflared access ssh --hostname %h\" >> ~/.ssh/config" >> create_ssh_config.sh
          echo "echo \"    User $REMOTE_USER\" >> ~/.ssh/config" >> create_ssh_config.sh
          echo "echo \"    StrictHostKeyChecking no\" >> ~/.ssh/config" >> create_ssh_config.sh
          echo "echo \"    UserKnownHostsFile /dev/null\" >> ~/.ssh/config" >> create_ssh_config.sh
          echo "echo \"    IdentityFile ~/.ssh/id_rsa\" >> ~/.ssh/config" >> create_ssh_config.sh
          
          # Execute script to create config
          chmod +x create_ssh_config.sh
          ./create_ssh_config.sh
          
          chmod 600 ~/.ssh/config
          
          # Display SSH config for debugging (with masking sensitive data)
          echo "SSH config created:"
          echo "Host: $REMOTE_HOST"
          echo "User: $REMOTE_USER"
          echo "Config file exists: $(test -f ~/.ssh/config && echo 'Yes' || echo 'No')"
          echo "Config file permissions: $(ls -la ~/.ssh/config | awk '{print $1}')"
          echo "SSH config content:"
          cat ~/.ssh/config

      # Deploy using Cloudflare SSH command
      - name: Deploy to production server
        env:
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          # Set default values if secrets are not defined
          if [ -z "$REMOTE_HOST" ]; then
            echo "REMOTE_HOST not defined in secrets, using default value"
            REMOTE_HOST="ssh.atlantis.trading"
          fi
          
          if [ -z "$REMOTE_USER" ]; then
            echo "REMOTE_USER not defined in secrets, using default value"
            REMOTE_USER="aj"
          fi
          
          # Print debug information about SSH parameters
          echo "==== SSH CONNECTION DEBUG INFO ===="
          echo "Target host: '$REMOTE_HOST'"
          echo "SSH user: '$REMOTE_USER'"
          echo "Docker username length: ${#DOCKERHUB_USERNAME}"
          echo "Docker token defined: $([ -n "$DOCKERHUB_TOKEN" ] && echo 'Yes' || echo 'No')"
          echo "SSH config file contents:"
          cat ~/.ssh/config
          echo "SSH config directory permissions:"
          ls -la ~/.ssh/
          echo "Using identity file: ~/.ssh/id_rsa (exists: $(test -f ~/.ssh/id_rsa && echo 'Yes' || echo 'No'))"
          echo "Identity file permissions: $(ls -la ~/.ssh/id_rsa | awk '{print $1}')"
          echo "Cloudflared cert exists: $(test -f ~/.cloudflared/cert.pem && echo 'Yes' || echo 'No')"
          echo "Cloudflared cert permissions: $(ls -la ~/.cloudflared/cert.pem | awk '{print $1}')"
          echo "Cloudflared version: $(cloudflared --version)"
          echo "Cloudflared info: $(cloudflared info)"
          echo "Which cloudflared: $(which cloudflared)"
          echo "ProxyCommand that will be used: $(grep ProxyCommand ~/.ssh/config | cut -d' ' -f3-)"
          echo "DNS resolution test for host: $(host $REMOTE_HOST || echo 'DNS resolution failed')"
          echo "==== END SSH DEBUG INFO ===="
          
          # Test SSH connection with all debug flags
          echo "Testing SSH connection with maximum verbosity..."
          ssh -vvv "$REMOTE_HOST" "echo SSH connection successful"
          
          # Now run the deployment commands
          ssh "$REMOTE_HOST" '
            cd /home/aj/dev/study
            git checkout prod
            git pull origin prod
            
            # Generate a unique tag based on commit SHA
            SHA_TAG=$(git rev-parse --short HEAD)
            echo "Using image tag: $SHA_TAG"
            
            # Set up environment for Docker login
            echo "Attempting Docker login on remote server..."
            
            # Use DOCKERHUB credentials for consistency across workflows
            echo "Running Docker login command..."
            docker login docker.io -u "'$DOCKERHUB_USERNAME'" -p "'$DOCKERHUB_TOKEN'" || {
              echo "Docker login failed with exit code $?"
              echo "Docker login error details:"
              docker info
              exit 1
            }
            echo "Docker login successful!"
            
            # Build and push images directly on the server
            echo "Building and pushing Docker images with tag: $SHA_TAG"
            
            # Backend
            echo "Building backend image..."
            docker build -t "'$DOCKERHUB_USERNAME'"/backend:latest -t "'$DOCKERHUB_USERNAME'"/backend:$SHA_TAG -f ./backend/Dockerfile.prod ./backend
            echo "Pushing backend images..."
            docker push "'$DOCKERHUB_USERNAME'"/backend:latest
            docker push "'$DOCKERHUB_USERNAME'"/backend:$SHA_TAG
            
            # Frontend
            echo "Building frontend image..."
            docker build -t "'$DOCKERHUB_USERNAME'"/frontend:latest -t "'$DOCKERHUB_USERNAME'"/frontend:$SHA_TAG -f ./frontend/Dockerfile.prod ./frontend
            echo "Pushing frontend images..."
            docker push "'$DOCKERHUB_USERNAME'"/frontend:latest
            docker push "'$DOCKERHUB_USERNAME'"/frontend:$SHA_TAG
            
            # Worker
            echo "Building worker image..."
            docker build -t "'$DOCKERHUB_USERNAME'"/worker:latest -t "'$DOCKERHUB_USERNAME'"/worker:$SHA_TAG -f ./worker/Dockerfile ./worker
            echo "Pushing worker images..."
            docker push "'$DOCKERHUB_USERNAME'"/worker:latest
            docker push "'$DOCKERHUB_USERNAME'"/worker:$SHA_TAG
            
            # Update image tags in manifests
            echo "Updating image tags in Kubernetes manifests..."
            sed -i "s|image: "'$DOCKERHUB_USERNAME'"/backend:latest|image: "'$DOCKERHUB_USERNAME'"/backend:$SHA_TAG|g" prod/config/backend.yaml
            sed -i "s|image: "'$DOCKERHUB_USERNAME'"/frontend:latest|image: "'$DOCKERHUB_USERNAME'"/frontend:$SHA_TAG|g" prod/config/frontend.yaml
            sed -i "s|image: "'$DOCKERHUB_USERNAME'"/worker:latest|image: "'$DOCKERHUB_USERNAME'"/worker:$SHA_TAG|g" prod/config/worker.yaml
            
            # Apply Kubernetes manifests with zero downtime strategy
            echo "Applying Kubernetes manifests..."
            
            # Apply database changes first and wait for readiness
            echo "Applying database configuration..."
            kubectl apply -f prod/config/db.yaml
            kubectl rollout status statefulset/db --timeout=300s
            
            # Apply cache service
            echo "Applying cache configuration..."
            kubectl apply -f prod/config/cache.yaml
            kubectl rollout status deployment/cache --timeout=300s
            
            # Apply backend services
            echo "Applying backend configuration..."
            kubectl apply -f prod/config/backend.yaml
            kubectl rollout status deployment/backend --timeout=300s
            
            # Apply worker services
            echo "Applying worker configuration..."
            kubectl apply -f prod/config/worker.yaml
            kubectl rollout status deployment/worker --timeout=300s
            
            # Apply frontend last
            echo "Applying frontend configuration..."
            kubectl apply -f prod/config/frontend.yaml
            kubectl rollout status deployment/frontend --timeout=300s
            
            # Apply nginx configuration
            echo "Applying nginx configuration..."
            kubectl apply -f prod/config/nginx.yaml
            kubectl rollout status deployment/nginx --timeout=300s
          ' 