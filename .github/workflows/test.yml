name: Deploy to Test Environment

on:
  push:
    branches:
      - test
  pull_request:
    branches:
      - test

jobs:
  deploy-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # Set up kubectl
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      # Simplified secrets check - only check critical ones
      - name: Verify essential secrets
        run: |
          missing_secrets=""
          [[ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]] && missing_secrets="${missing_secrets} SSH_PRIVATE_KEY"
          [[ -z "${{ secrets.CLOUDFLARE_CERT }}" ]] && missing_secrets="${missing_secrets} CLOUDFLARE_CERT"
          [[ -z "${{ secrets.DOCKERHUB_USERNAME }}" ]] && missing_secrets="${missing_secrets} DOCKERHUB_USERNAME"
          [[ -z "${{ secrets.DOCKERHUB_TOKEN }}" ]] && missing_secrets="${missing_secrets} DOCKERHUB_TOKEN"
          
          if [[ ! -z "$missing_secrets" ]]; then
            echo "ERROR: Missing required secrets:$missing_secrets"
            exit 1
          fi
          echo "Essential secrets verified"

      # Install Cloudflared - required for secure SSH tunneling through Cloudflare Access
      - name: Install Cloudflared
        run: |
          curl -L --output cloudflared.deb https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared.deb

      # Use ssh-agent for SSH key management
      - name: Set up SSH key using ssh-agent
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      
      # Set up Cloudflare access and SSH config
      - name: Configure Cloudflare Access
        env:
          REMOTE_HOST: ${{ secrets.REMOTE_HOST || 'ssh.atlantis.trading' }}
          REMOTE_USER: ${{ secrets.REMOTE_USER || 'aj' }}
          CLOUDFLARE_CERT: ${{ secrets.CLOUDFLARE_CERT }}
        run: |
          # Set up Cloudflare certificate
          mkdir -p ~/.cloudflared
          echo "$CLOUDFLARE_CERT" > ~/.cloudflared/cert.pem
          chmod 600 ~/.cloudflared/cert.pem
          
          # Create SSH config
          mkdir -p ~/.ssh
          
          cat > ~/.ssh/config << EOF
Host $REMOTE_HOST
    ProxyCommand cloudflared access ssh --hostname %h
    User $REMOTE_USER
    StrictHostKeyChecking no
    UserKnownHostsFile /dev/null
    ServerAliveInterval 60
    ConnectTimeout 30
    KexAlgorithms +diffie-hellman-group1-sha1,diffie-hellman-group14-sha1
    PubkeyAcceptedAlgorithms +ssh-rsa
    HostkeyAlgorithms +ssh-rsa
EOF
          
          chmod 600 ~/.ssh/config

      # Deploy using Cloudflare SSH command to test environment
      - name: Deploy to test environment
        env:
          REMOTE_USER: ${{ secrets.REMOTE_USER || 'aj' }}
          REMOTE_HOST: ${{ secrets.REMOTE_HOST || 'ssh.atlantis.trading' }}
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
          DB_ROOT_PASSWORD: ${{ secrets.DB_ROOT_PASSWORD }}
        run: |
          # Test SSH connection
          echo "Testing SSH connection..."
          if ! ssh -q "$REMOTE_HOST" "echo SSH connection successful"; then
            echo "SSH connection failed. Checking SSH agent..."
            ssh-add -L
            exit 1
          fi
          
          # Now run the deployment commands
          ssh "$REMOTE_HOST" '
            cd /home/aj/dev/study
            git checkout test
            git pull origin test
            
            # Generate a unique tag based on commit SHA
            SHA_TAG=$(git rev-parse --short HEAD)
            echo "Using image tag: $SHA_TAG for TEST deployment"
            
            # Verify Docker is running and start it if needed
            if ! docker info &>/dev/null; then
              echo "Docker is not running. Attempting to start Docker service..."
              if command -v systemctl &>/dev/null; then
                sudo systemctl start docker
                sleep 5
                # Verify docker started successfully
                if ! docker info &>/dev/null; then
                  echo "ERROR: Failed to start Docker service"
                  exit 1
                fi
                echo "Docker service started successfully"
              else
                echo "ERROR: Cannot start Docker - systemctl not available"
                exit 1
              fi
            fi
            
            # Log in to Docker Hub
            echo "Logging in to Docker Hub..."
            docker login -u "'$DOCKERHUB_USERNAME'" -p "'$DOCKERHUB_TOKEN'" || {
              echo "ERROR: Docker login failed"
              exit 1
            }
            
            # Check and start Minikube
            if ! command -v minikube &>/dev/null; then
              echo "Installing Minikube..."
              curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
              chmod +x minikube
              sudo mv minikube /usr/local/bin/
            fi
            
            # Check if Minikube is running, start it if not
            if ! minikube status &>/dev/null; then
              echo "Starting Minikube..."
              minikube start --driver=docker || {
                # If docker driver fails, try alternative drivers
                if command -v virsh &>/dev/null; then
                  minikube start --driver=kvm2
                else
                  minikube start --driver=podman || minikube start --driver=none
                fi
              }
            fi
            
            # Ensure kubectl is configured for Minikube
            eval $(minikube -p minikube docker-env)
            
            # Set namespace for test deployment
            TEST_NAMESPACE="test"
            kubectl create namespace $TEST_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
            
            # Define containers to build and deploy
            CONTAINERS=("backend" "frontend" "worker")
            
            # Build and push container images
            echo "Building and pushing Docker images..."
            for CONTAINER in "${CONTAINERS[@]}"; do
              echo "Processing $CONTAINER..."
              
              # Determine dockerfile path
              DOCKERFILE="./Dockerfile"
              if [ "$CONTAINER" != "worker" ]; then
                DOCKERFILE="./Dockerfile.prod"
              fi
              
              # Build and push
              docker build -t "'$DOCKERHUB_USERNAME'"/$CONTAINER:test -t "'$DOCKERHUB_USERNAME'"/$CONTAINER:test-$SHA_TAG -f ./$CONTAINER$DOCKERFILE ./$CONTAINER || {
                echo "ERROR: Failed to build $CONTAINER image"
                exit 1
              }
              
              docker push "'$DOCKERHUB_USERNAME'"/$CONTAINER:test || {
                echo "ERROR: Failed to push $CONTAINER:test image"
                exit 1
              }
              
              docker push "'$DOCKERHUB_USERNAME'"/$CONTAINER:test-$SHA_TAG || {
                echo "ERROR: Failed to push $CONTAINER:test-$SHA_TAG image"
                exit 1
              }
            done
            
            # Update config files for test environment
            echo "Updating Kubernetes manifests..."
            mkdir -p test/config
            cp -rf prod/config/* test/config/
            
            # Update namespace and image tags in test config files
            for file in test/config/*.yaml; do
              sed -i "s/namespace: default/namespace: $TEST_NAMESPACE/g" "$file"
              sed -i "s/name: production/name: test/g" "$file"
            done
            
            # Update image tags 
            for CONTAINER in "${CONTAINERS[@]}"; do
              sed -i "s|image: "'$DOCKERHUB_USERNAME'"/$CONTAINER:latest|image: "'$DOCKERHUB_USERNAME'"/$CONTAINER:test-$SHA_TAG|g" test/config/$CONTAINER.yaml
            done
            
            # Apply Kubernetes manifests with zero downtime strategy for test environment
            echo "Applying Kubernetes manifests for test environment..."
            
            # Apply configurations in proper order and verify deployment
            COMPONENTS=("db" "cache" "backend" "worker" "frontend")
            
            for COMPONENT in "${COMPONENTS[@]}"; do
              echo "Deploying $COMPONENT..."
              kubectl apply -f test/config/$COMPONENT.yaml
              
              # Wait for rollout completion
              if [ "$COMPONENT" = "db" ]; then
                kubectl rollout status statefulset/$COMPONENT -n $TEST_NAMESPACE --timeout=300s || {
                  echo "ERROR: $COMPONENT deployment failed"
                  exit 1
                }
              else
                kubectl rollout status deployment/$COMPONENT -n $TEST_NAMESPACE --timeout=300s || {
                  echo "ERROR: $COMPONENT deployment failed"
                  exit 1
                }
              fi
            done
            
            # Apply nginx configuration
            echo "Applying nginx configuration..."
            kubectl apply -f test/config/nginx.yaml -n $TEST_NAMESPACE
            
            # Expose ingress controller with NodePort
            echo "Exposing ingress controller..."
            kubectl -n $TEST_NAMESPACE expose deployment ingress-nginx-controller \
              --name=ingress-nginx-nodeport-test \
              --port=80 \
              --target-port=80 \
              --type=NodePort \
              --overrides='\{"spec":\{"ports":[{"port":80,"protocol":"TCP","targetPort":80,"nodePort":30082}]\}\}'
            
            # Verify ingress resources
            kubectl get ingress -n $TEST_NAMESPACE
            echo "Test deployment completed successfully!"
          ' 

      - name: Set environment variables for test
        id: env
        run: |
          echo "ENVIRONMENT=test" >> $GITHUB_ENV
          echo "DOMAIN=dev.atlantis.trading" >> $GITHUB_ENV
          echo "NAMESPACE=test" >> $GITHUB_ENV
          echo "DEPLOY_ID=$(date +%s)-$(echo $GITHUB_SHA | cut -c1-7)" >> $GITHUB_ENV
          echo "deploy_id=$(date +%s)-$(echo $GITHUB_SHA | cut -c1-7)" >> $GITHUB_OUTPUT
