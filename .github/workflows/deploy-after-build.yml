name: Deploy After Successful Build

on:
  workflow_run:
    workflows: ["Lint and Build Check"]
    types:
      - completed
    branches:
      - dev
      - prod

jobs:
  deploy-if-build-succeeded:
    runs-on: self-hosted
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    
    steps:
      - name: Debug Event Information
        run: |
          echo "Workflow run event triggered by: ${{ github.event.workflow_run.head_branch }}"
          echo "Workflow run conclusion: ${{ github.event.workflow_run.conclusion }}"
          echo "Workflow run name: ${{ github.event.workflow_run.name }}"
      
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.workflow_run.head_branch }}
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 1
          lfs: false
      
      - name: Show Git Information
        run: |
          echo "Current directory: $(pwd)"
          echo "Directory contents: $(ls -la)"
          echo "Git status: $(git status)"
          echo "Current branch: $(git branch --show-current)"
      
      # Verify secrets are available without exposing them
      - name: Verify Docker Credentials
        run: |
          echo "Docker username secret: $(if [ -n "${{ secrets.DOCKER_USERNAME }}" ]; then echo "is set"; else echo "is NOT set"; fi)"
          echo "Docker token secret: $(if [ -n "${{ secrets.DOCKER_TOKEN }}" ]; then echo "is set"; else echo "is NOT set"; fi)"
      
      # Setup and configuration
      - name: Setup deployment
        run: |
          # Function to log messages with timestamps
          log() {
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
          }

          # Function to log errors
          error_log() {
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $1" >&2
          }

          # Print diagnostic information
          log "Deployment script diagnostics:"
          log "Current working directory: $(pwd)"
          log "Current user: $(whoami)"
          log "Current branch: ${{ github.event.workflow_run.head_branch }}"
          
          # Sanitize branch name for Docker tags (replace / with - and other invalid characters)
          DOCKER_TAG=$(echo "${{ github.event.workflow_run.head_branch }}" | sed 's/\//-/g' | sed 's/[^a-zA-Z0-9_.-]/-/g')
          echo "DOCKER_TAG=${DOCKER_TAG}" >> $GITHUB_ENV
          
          log "Docker tag: ${DOCKER_TAG}"
          log "Files in current directory: $(ls -la)"
          log "Starting deployment process for branch: ${{ github.event.workflow_run.head_branch }}..."
          log "Using already checked out code for deployment..."

      # Build Docker images
      - name: Build Docker Images
        run: |
          # Function to log messages with timestamps
          log() {
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
          }
          
          # Function to log errors
          error_log() {
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $1" >&2
          }
          
          # Check Docker username and fail if not set
          DOCKER_USERNAME="${{ secrets.DOCKER_USERNAME }}"
          if [ -z "$DOCKER_USERNAME" ]; then
            error_log "DOCKER_USERNAME secret is not available"
            error_log "Please add the DOCKER_USERNAME secret in your GitHub repository:"
            error_log "1. Go to your repository on GitHub"
            error_log "2. Navigate to Settings > Secrets and variables > Actions"
            error_log "3. Click 'New repository secret'"
            error_log "4. Name: DOCKER_USERNAME"
            error_log "5. Value: Your Docker Hub username"
            error_log "6. Click 'Add secret'"
            exit 1
          fi
          echo "DOCKER_USERNAME=${DOCKER_USERNAME}" >> $GITHUB_ENV
          
          log "Building Docker images with tag: ${{ env.DOCKER_TAG }}..."
          log "Using Docker username: ${DOCKER_USERNAME}"
          
          docker build -t ${DOCKER_USERNAME}/frontend:${{ env.DOCKER_TAG }} -f frontend/Dockerfile.prod frontend
          docker build -t ${DOCKER_USERNAME}/backend:${{ env.DOCKER_TAG }} -f backend/Dockerfile.prod backend
          docker build -t ${DOCKER_USERNAME}/worker:${{ env.DOCKER_TAG }} -f worker/Dockerfile.prod worker
          docker build -t ${DOCKER_USERNAME}/tf:${{ env.DOCKER_TAG }} -f tf/Dockerfile.prod tf
          docker build -t ${DOCKER_USERNAME}/db:${{ env.DOCKER_TAG }} -f db/Dockerfile.prod db
          
          # For prod branch, also tag as latest
          # For dev branch, also tag as development
          if [ "${{ github.event.workflow_run.head_branch }}" = "prod" ]; then
            log "Tagging images as 'latest' for production..."
            docker tag ${DOCKER_USERNAME}/frontend:${{ env.DOCKER_TAG }} ${DOCKER_USERNAME}/frontend:latest
            docker tag ${DOCKER_USERNAME}/backend:${{ env.DOCKER_TAG }} ${DOCKER_USERNAME}/backend:latest
            docker tag ${DOCKER_USERNAME}/worker:${{ env.DOCKER_TAG }} ${DOCKER_USERNAME}/worker:latest
            docker tag ${DOCKER_USERNAME}/tf:${{ env.DOCKER_TAG }} ${DOCKER_USERNAME}/tf:latest
            docker tag ${DOCKER_USERNAME}/db:${{ env.DOCKER_TAG }} ${DOCKER_USERNAME}/db:latest
          elif [ "${{ github.event.workflow_run.head_branch }}" = "dev" ]; then
            log "Tagging images as 'development' for development environment..."
            docker tag ${DOCKER_USERNAME}/frontend:${{ env.DOCKER_TAG }} ${DOCKER_USERNAME}/frontend:development
            docker tag ${DOCKER_USERNAME}/backend:${{ env.DOCKER_TAG }} ${DOCKER_USERNAME}/backend:development
            docker tag ${DOCKER_USERNAME}/worker:${{ env.DOCKER_TAG }} ${DOCKER_USERNAME}/worker:development
            docker tag ${DOCKER_USERNAME}/tf:${{ env.DOCKER_TAG }} ${DOCKER_USERNAME}/tf:development
            docker tag ${DOCKER_USERNAME}/db:${{ env.DOCKER_TAG }} ${DOCKER_USERNAME}/db:development
          fi

      # Push Docker images
      - name: Login to Docker Hub and Push Images
        run: |
          # Function to log messages with timestamps
          log() {
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
          }
          
          # Function to log errors
          error_log() {
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $1" >&2
          }
          
          log "Preparing to push Docker images to registry with tag: ${{ env.DOCKER_TAG }}..."
          
          # Check Docker token and fail if not set
          if [ -z "${{ secrets.DOCKER_TOKEN }}" ]; then
            error_log "DOCKER_TOKEN secret is not available"
            error_log "Please add the DOCKER_TOKEN secret in your GitHub repository:"
            error_log "1. Go to your repository on GitHub"
            error_log "2. Navigate to Settings > Secrets and variables > Actions"
            error_log "3. Click 'New repository secret'"
            error_log "4. Name: DOCKER_TOKEN"
            error_log "5. Value: Your Docker Hub access token"
            error_log "6. Click 'Add secret'"
            exit 1
          fi
          
          # Directly use GitHub secrets for Docker login
          log "Logging into Docker Hub using username: ${{ env.DOCKER_USERNAME }}..."
          echo "${{ secrets.DOCKER_TOKEN }}" | docker login -u "${{ env.DOCKER_USERNAME }}" --password-stdin || {
            error_log "Docker login failed. Please check your credentials."
            exit 1
          }
          
          log "Docker login successful, proceeding with image push..."
          
          # Push images with the branch-specific tag
          docker push ${{ env.DOCKER_USERNAME }}/frontend:${{ env.DOCKER_TAG }}
          docker push ${{ env.DOCKER_USERNAME }}/backend:${{ env.DOCKER_TAG }}
          docker push ${{ env.DOCKER_USERNAME }}/worker:${{ env.DOCKER_TAG }}
          docker push ${{ env.DOCKER_USERNAME }}/tf:${{ env.DOCKER_TAG }}
          docker push ${{ env.DOCKER_USERNAME }}/db:${{ env.DOCKER_TAG }}
          
          # Push additional tags based on branch
          if [ "${{ github.event.workflow_run.head_branch }}" = "prod" ]; then
            log "Pushing 'latest' tagged images..."
            docker push ${{ env.DOCKER_USERNAME }}/frontend:latest
            docker push ${{ env.DOCKER_USERNAME }}/backend:latest
            docker push ${{ env.DOCKER_USERNAME }}/worker:latest
            docker push ${{ env.DOCKER_USERNAME }}/tf:latest
            docker push ${{ env.DOCKER_USERNAME }}/db:latest
          elif [ "${{ github.event.workflow_run.head_branch }}" = "dev" ]; then
            log "Pushing 'development' tagged images..."
            docker push ${{ env.DOCKER_USERNAME }}/frontend:development
            docker push ${{ env.DOCKER_USERNAME }}/backend:development
            docker push ${{ env.DOCKER_USERNAME }}/worker:development
            docker push ${{ env.DOCKER_USERNAME }}/tf:development
            docker push ${{ env.DOCKER_USERNAME }}/db:development
          fi

      # Deploy to Kubernetes
      - name: Deploy to Kubernetes
        run: |
          # Function to log messages with timestamps
          log() {
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
          }

          # Function to log errors
          error_log() {
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $1" >&2
          }
          
          # Apply Kubernetes configurations
          log "Applying Kubernetes configurations..."
          if [ "${{ github.event.workflow_run.head_branch }}" = "dev" ]; then
            # Dev-specific configurations (if they exist)
            if [ -d "prod/config/dev" ]; then
              kubectl apply -f prod/config/dev
            else
              # Fall back to prod config if no dev config exists
              kubectl apply -f prod/config
            fi
          else
            # Default to prod config for prod branch or any other branch
            kubectl apply -f prod/config
          fi
          
          # Add debugging information about the cluster and deployments
          log "Getting cluster information before deployment..."
          kubectl get nodes
          kubectl get pods -o wide
          kubectl get deployments
          
          # Check if backend deployment exists
          if ! kubectl get deployment backend &> /dev/null; then
            error_log "Backend deployment not found! Checking namespace..."
            kubectl get namespaces
            exit 1
          fi
          
          # Perform rolling updates for zero downtime using branch-specific image tags
          log "Performing rolling updates for zero downtime using images tagged with: ${{ env.DOCKER_TAG }}..."
          
          # Update backend deployment with timeout handling
          log "Updating backend deployment..."
          kubectl set image deployment/backend backend=${{ env.DOCKER_USERNAME }}/backend:${{ env.DOCKER_TAG }}
          
          # Monitor rollout with a timeout
          log "Monitoring backend rollout status..."
          timeout=300  # 5 minutes timeout
          start_time=$(date +%s)
          
          while true; do
            status=$(kubectl rollout status deployment/backend --timeout=10s || echo "FAILED")
            current_time=$(date +%s)
            elapsed=$((current_time - start_time))
            
            if [[ $status != *"FAILED"* ]]; then
              log "Backend deployment succeeded after ${elapsed} seconds."
              break
            fi
            
            if [ $elapsed -gt $timeout ]; then
              error_log "Backend deployment timed out after ${elapsed} seconds."
              log "Collecting debug information..."
              kubectl describe deployment backend
              kubectl get pods -l app=backend
              kubectl logs -l app=backend --tail=50
              kubectl get events --sort-by='.lastTimestamp'
              
              # Continue with other deployments instead of failing
              log "Continuing with other deployments despite backend failure..."
              break
            fi
            
            log "Still waiting for backend deployment... (${elapsed}s elapsed)"
            sleep 10
          done
          
          # Update frontend deployment
          log "Updating frontend deployment..."
          kubectl set image deployment/frontend frontend=${{ env.DOCKER_USERNAME }}/frontend:${{ env.DOCKER_TAG }}
          kubectl rollout status deployment/frontend --timeout=5m || {
            error_log "Frontend deployment failed or timed out."
            kubectl describe deployment frontend
            # Continue with other deployments
          }
          
          # Update worker deployment - fix the container name from 'backend' to 'worker'
          log "Updating worker deployment..."
          kubectl set image deployment/worker worker=${{ env.DOCKER_USERNAME }}/worker:${{ env.DOCKER_TAG }}
          kubectl rollout status deployment/worker --timeout=5m || {
            error_log "Worker deployment failed or timed out."
            kubectl describe deployment worker
            # Continue with other deployments
          }
          
          # Update tf deployment
          log "Updating tf deployment..."
          kubectl set image deployment/tf tf=${{ env.DOCKER_USERNAME }}/tf:${{ env.DOCKER_TAG }}
          kubectl rollout status deployment/tf --timeout=5m || {
            error_log "TF deployment failed or timed out."
            kubectl describe deployment tf
            # Continue with other deployments
          }
          
          # Final status check
          log "Checking final deployment status..."
          kubectl get deployments
          
          log "Deployment process completed for branch ${{ github.event.workflow_run.head_branch }}." 