This style guide outlines the conventions we follow across the Peripheral codebase to ensure consistency and readability. Our overarching principle is consistency – in naming, structure, and formatting.
Naming Conventions
CamelCase Everywhere: We enforce camelCase naming for variables, functions, and most identifiers across all languages in this project

. This is unusual for some languages (Python, SQL, CSS), but it greatly improves consistency when reading multi-language code. For example:
Variables and function names use lowerCamelCase (e.g., userId, getPriceData).
Classes (in languages that use them, like Python or TS) use UpperCamelCase (PascalCase) (e.g., TradeExecutor class).
Constants: Use ALL_CAPS with underscores if truly constant (e.g., MAX_RETRY_COUNT in Python, following typical constants style). However, in Go, use CamelCase for exported constants as per Go conventions.
Filenames:
Go files: all lowercase, with underscores if needed (Go package names are one word, e.g., securities.go, strategy.go).
Python files: lowercase, can use underscores (e.g., data_provider.py).
Svelte/TS files: use kebab-case or PascalCase as appropriate for components (Svelte components often Capitalized, e.g., ChartWidget.svelte, utility TS files in lowercase or camelCase).
SQL migration files: use snake_case for file names if generated by a tool, but within SQL, object names are CamelCase.
Database tables & columns: use lowerCamelCase as well (e.g., table userTrades, column createdAt). Keywords in SQL are uppercase (SELECT, WHERE) for clarity

.
Examples:
go
Copy
Edit
// Go example
type UserProfile struct {
    userId   int
    userName string
}
func getUserData(id int) {}
python
Copy
Edit
# Python example
userName = "Alice"
def calculateReturnRate():
    pass
ts
Copy
Edit
// TypeScript example
let currentPrice: number;
function updateChartData() { ... }
sql
Copy
Edit
-- SQL example
SELECT userId, userName FROM userTrades WHERE createdAt > '2024-01-01';
In all above, userId and userName use CamelCase. Incorrect would be user_id or user_name (snake_case) in these contexts, which our linters will flag as errors. CSS: We even use camelCase for CSS class names (e.g., .tradeWidget { ... }), rather than hyphenated, to keep consistency with component naming

. (Exception: built-in or third-party frameworks that expect hyphen-case, but currently we try to stick to our style.) Exceptions:
Third-party library usages: If a Python library expects snake_case arguments or returns keys in snake_case, that's acceptable for that interaction (but we may convert to camelCase when storing or using internally).
Standard acronyms: You can preserve common capitalization for readability, e.g., getCPUUsage or sendHTTPrequest (capitalize as words, not all-caps).
Python: Standard library modules and names (e.g., import os, json.loads) remain as is; don't try to CamelCase those.
Constants: As noted, UPPER_SNAKE_CASE for constants in Python (since PEP8 allows that) and environment variables.
SQL: As noted, SQL keywords are UPPERCASE, string literals are case-insensitive to style, and snake_case might appear in some legacy table names if unavoidable (but new schema objects should use camelCase).
Code Layout & Structure
Go:
Use Go standard project layout. Our Go code resides in services/backend/internal/....
Ordering: Within a Go file, typically import blocks (stdlib, then third-party, then internal packages) separated by blank lines. Then consts, vars, type declarations, then functions. Exported functions at top, unexported helper functions later (if it improves clarity).
Error handling: Check err immediately after calls; use early returns to keep indentation shallow.
Comments: Public (exported) functions and types should have comments (will be picked up by golint). Use complete sentences starting with the name, e.g., // CreateUser creates a new user in the database....
Format: Always run gofmt (or have your editor do it on save). Our CI will reject PRs where gofmt or golangci-lint finds issues.
Python:
Indentation 4 spaces (no tabs). Use blank lines sparingly to separate logical sections of code.
Imports: Group imports into three sections with blank lines between: standard library, third-party packages, local application imports. Within each section, sort alphabetically.
Line length: Aim for 88 characters (PEP8 default via Black) or 100 max; our lint isn’t strict on this, but readability suffers if lines are too long.
Functions: Include docstrings for modules, classes, and major functions using triple quotes """Doc...""". For one-line trivial functions, a comment above can suffice.
Type hints: We require type hints for function definitions and prefer them for critical variables. This helps with static analysis (we run mypy in CI for type checking).
Naming: As noted, use CamelCase for variables and functions (breaking PEP8 convention intentionally)

. Class names still UpperCamelCase as usual. Use lowercase_with_underscores for module names (filenames), which is typical.
Function size should be determined by what makes the code most readable and maintainable, balancing clarity with ease of editing and understanding.
TypeScript & Svelte:
Use 2 spaces for indentation (default in most linters).
In TypeScript, always declare types for function return values and parameters. Use interfaces or types for complex objects instead of any.
Organize imports with built-ins (Node/browser APIs) first, then external libraries, then local modules. Some linters autofix import order.
Component structure: in Svelte components, script at top, then markup, then styling at bottom (if using <style> in component). Exported component props should be clearly commented.
Prefer built-in Svelte stores and actions for state management rather than writing direct DOM manipulation or manual event handlers if reactivity can handle it.
CSS: co-locate component-specific styles in the Svelte file using <style> (scoped by default). Use global styles sparingly (e.g., a global reset or theme CSS).
Use prettier (our ESLint is configured to catch formatting issues). Quotes should be single quotes (except when using double quotes in HTML templates where needed), and semicolons are generally included as per default TS style.
SQL:
We format SQL queries with keywords in uppercase and indenting inner clauses for readability. For example:
sql
Copy
Edit
SELECT userId, userName 
FROM userTrades 
WHERE createdAt > '2024-01-01'
  AND status = 'OPEN'
ORDER BY createdAt DESC;
Even though our database identifiers are CamelCase, when writing raw SQL, you can use quotes if needed to preserve case (Postgres is case-sensitive with quoted identifiers). However, we've chosen identifiers such that unquoted usage (which lowercases them) is fine too.
Use CTEs (WITH clauses) for complex queries instead of sub-selects for clarity.
When writing migrations, include comments at top describing the change. Test your migration upward and downward if possible.
Comments and Documentation
Use comments to explain why something is done, especially if non-obvious or tricky. Avoid stating the obvious what (the code often shows that).
For any workaround or hacky solution, include a TODO or FIXME with an explanation so future maintainers know to revisit it.
Documentation-wise, if you add a new significant feature, consider updating or adding to docs/ with design rationale or user guides, so others (and our AI assistant) can be aware.
Example Patterns
To illustrate the style, here's a small snippet combining our conventions (in Go):
go
Copy
Edit
// GetOpenTrades retrieves all open trades for a user.
func GetOpenTrades(conn *data.Conn, userId int) ([]Trade, error) {
    // Query the database for open trades
    rows, err := conn.DB.Query(context.Background(),
        `SELECT tradeId, symbol, quantity, entryPrice, createdAt
         FROM userTrades
         WHERE userId=$1 AND status='OPEN';`, userId)
    if err != nil {
        return nil, fmt.Errorf("db query failed: %w", err)
    }
    defer rows.Close()

    trades := []Trade{}
    for rows.Next() {
        var t Trade
        if err := rows.Scan(&t.TradeID, &t.Symbol, &t.Quantity, &t.EntryPrice, &t.CreatedAt); err != nil {
            return nil, err
        }
        trades = append(trades, t)
    }
    return trades, nil
}
Notice the CamelCase in SQL identifiers, early error handling, and a comment explaining the function’s purpose. This is representative of clean code in our codebase.
Tools
Many style conventions are enforced by automated tools:
Prettier/ESLint (for frontend) – auto-formats code on save (if editor configured) or via npm run format.
golangci-lint (for Go) – catches style issues, unused code, etc.
Pylint/flake8 (for Python) – highlights naming issues, formatting concerns.
SQLFluff (for SQL) – lints SQL files for formatting consistency (our config enforces uppercase keywords and CamelCase identifiers)

.
Stylelint (for CSS) – enforces our CSS naming pattern and formatting for any standalone CSS files.
It’s recommended to run these linters locally (see LINTING.md for specifics on running each) before pushing code. Our CI will run all these checks on every push and PR as well. By adhering to this style guide, we maintain a codebase that is easy to read and maintain, reducing cognitive load when switching between languages and components. Consistency is key – when in doubt, follow the conventions you see elsewhere in the project or ask a senior team member for guidance.