function backendLoadChartData(inst:ChartRequest): void{
        if (inst.requestType === "loadNewTicker"){
            bidLine.setData([])
            askLine.setData([])
        }

        if (isLoadingChartData ||!inst.ticker || !inst.timeframe || !inst.securityId) { return; }
        isLoadingChartData = true;
        lastChartRequestTime = Date.now()
        if((get(replayInfo).status == "active" || get(replayInfo).status == "paused") && inst.timestamp == 0) {
            inst.timestamp = Math.floor(get(currentTimestamp))
        }
        
        privateRequest<BarData[]>("getChartData", {
            securityId:inst.securityId, 
            timeframe:inst.timeframe, 
            timestamp:inst.timestamp, 
            direction:inst.direction, 
            bars:inst.bars,
            extendedhours:inst.extendedHours, 
            isreplay: (get(replayInfo).status == "active" || get(replayInfo).status == "paused") ? true : false,}
            ,true)
            .then((barDataList: BarData[]) => {
                blockingChartRequest = inst
                if (! (Array.isArray(barDataList) && barDataList.length > 0)){ return}
                let newCandleData = barDataList.map((bar) => ({
                  time: UTCSecondstoESTSeconds(bar.time as UTCTimestamp) as UTCTimestamp,
                  open: bar.open, 
                  high: bar.high, 
                  low: bar.low, 
                  close: bar.close, 
                }));
                let newVolumeData: any
                if (get(settings).dolvol){
                    newVolumeData = barDataList.map((bar) => ({
                      time: UTCSecondstoESTSeconds(bar.time as UTCTimestamp) as UTCTimestamp, value: bar.volume * (bar.close + bar.open) / 2, color: bar.close > bar.open ? '#089981' : '#ef5350', }));
                }else{
                    newVolumeData = barDataList.map((bar) => ({
                      time: UTCSecondstoESTSeconds(bar.time as UTCTimestamp) as UTCTimestamp, value: bar.volume, color: bar.close > bar.open ? '#089981' : '#ef5350', }));
                }
                if (inst.requestType === 'loadAdditionalData' && inst.direction === 'backward') {
                  const earliestCandleTime = chartCandleSeries.data()[0]?.time;
                  if (typeof earliestCandleTime === 'number' && newCandleData[newCandleData.length - 1].time <= earliestCandleTime) {
                    newCandleData = [...newCandleData.slice(0, -1), ...chartCandleSeries.data()] as any;
                    newVolumeData = [...newVolumeData.slice(0, -1), ...chartVolumeSeries.data()] as any;
                  }
                } else if (inst.requestType === 'loadAdditionalData') {
                  const latestCandleTime = chartCandleSeries.data()[chartCandleSeries.data().length - 1]?.time;
                  if (typeof latestCandleTime === 'number' && newCandleData[0].time >= latestCandleTime) {
                    newCandleData = [...chartCandleSeries.data(), ...newCandleData.slice(1)] as any;
                    newVolumeData = [...chartVolumeSeries.data(), ...newVolumeData.slice(1)] as any;
                  }
                } else if(inst.requestType === 'loadNewTicker') {
                    const lastBar = newCandleData[newCandleData.length - 1]
                    //bidLine.setData([{time:lastBar.time,value:lastBar.close}])
                    if(inst.includeLastBar == false && $replayInfo.status !== 'inactive') {
                        // cuts off the last bar 
                        newCandleData = newCandleData.slice(0, newCandleData.length-1)
                        newVolumeData = newVolumeData.slice(0, newVolumeData.length-1)
                    }
                    const [priceStore, r] = getStream<TradeData[]>(inst, 'fast')
                    release = r
                    unsubscribe = priceStore.subscribe((v:TradeData[]) => {
                        updateLatestChartBar(v)
                    })
                    const [quoteStore, rq] = getStream<QuoteData[]>(inst, 'quote')
                    releaseQuote = rq
                    unsubscribeQuote = quoteStore.subscribe((v:QuoteData[]) => {
                        updateLatestQuote(v)
                    })
                }
                // Check if we reach end of avaliable data 
                if (inst.timestamp == 0) {
                    chartLatestDataReached = true;
                }
                if (barDataList.length < inst.bars) {

                    if(inst.direction == 'backward') {
                        chartEarliestDataReached = true;
                    } else if (inst.direction == "forward"){
                        chartLatestDataReached = true;
                    }
                }
                queuedLoad = () => {
                        console.log("queued load time", Date.now())
                        if (inst.direction == "forward") {
                            const visibleRange = chart.timeScale().getVisibleRange()
                            const vrFrom = visibleRange?.from as Time
                            const vrTo = visibleRange?.to as Time
                            chartCandleSeries.setData(newCandleData);
                            chartVolumeSeries.setData(newVolumeData);
                            chart.timeScale().setVisibleRange({from: vrFrom, to: vrTo})
                        }else if (inst.direction == "backward"){
                            chartCandleSeries.setData(newCandleData);
                            chartVolumeSeries.setData(newVolumeData);
                        }
                        queuedLoad = null
                        sma10Series.setData(calculateSMA(newCandleData, 10));
                        sma20Series.setData(calculateSMA(newCandleData, 20));
                        if (inst.requestType == 'loadNewTicker') {
                            chart.timeScale().resetTimeScale()
                            //chart.timeScale().fitContent();
                            if (currentChartInstance.timestamp === 0){
                                chart.timeScale().applyOptions({
                                rightOffset: 10
                                });
                            }else{
                                chart.timeScale().applyOptions({
                                rightOffset: 0
                                });
                            }

                        }
                        isLoadingChartData = false; // Ensure this runs after data is loaded
                }
                // Handling the aggregation of the most recent candle 
                if(inst.timestamp == 0) { // IF REAL TIME DATA 
                    var referenceStartTime; 
                    var aggregateOpen: number;
                    var aggregateHigh: number;
                    var aggregateLow: number;
                    var aggregateClose: number; 
                    if(inst.timeframe?.includes('m')) {
                        const now = getRealTimeTime()
                        const referenceDateTime = DateTime.fromObject({year:2003, month:9, day:1, minute:0, second:0, millisecond:0,}, {zone: 'America/New_York'});
                        const nowDateTime = DateTime.fromMillis(now)
                        const elapsedTimeInMonths = nowDateTime.diff(referenceDateTime, 'months').months;
                        const numFullBars = Math.floor(elapsedTimeInMonths / parseInt(inst.timeframe));
                        const candleStartDateTime = referenceDateTime.plus({ months: numFullBars * parseInt(inst.timeframe) });

                        const candleStartTimeUTC = candleStartDateTime.toUTC().toMillis();
                        referenceStartTime = getReferenceStartTimeForDateMilliseconds(now, false) // market open time of the day
                        console.log("candleStartTime:", candleStartTimeUTC)
                        const lastBar = newCandleData[newCandleData.length - 1];
                        const lastBarTimeMs = ESTSecondstoUTCMillis(lastBar.time); 
                        const lastCompleteDayUTC = DateTime.fromMillis(UTCSecondstoESTSeconds(now/1000)*1000).startOf('day')
                        let dayBarsEndTimeUTC = lastCompleteDayUTC.toMillis();
                        if(dayBarsEndTimeUTC <= candleStartTimeUTC) {
                            dayBarsEndTimeUTC = candleStartTimeUTC;
                        }
                        const dailyBarsDurationMs = dayBarsEndTimeUTC - candleStartTimeUTC; 
                        console.log("dailyBarsDurationMs", dailyBarsDurationMs)
                        const numDailyBars = Math.floor(dailyBarsDurationMs / (86400000))
                        console.log('numDailyBars', numDailyBars)
                        let dailyBarsPromise: Promise<BarData[]> = Promise.resolve([]);
                        if(numDailyBars > 0) {
                            dailyBarsPromise = privateRequest<BarData[]>("getChartData", {
                                securityId: inst.securityId,
                                timeframe: "1d",
                                timestamp: candleStartTimeUTC, 
                                direction: "forward",
                                bars: numDailyBars, 
                                extendedhours: false, 
                                isreplay: true,
                            })
                        }
                        const lastCompleteMinuteUTC = DateTime.fromMillis(UTCSecondstoESTSeconds(now/1000)*1000).startOf('minute')
                        let minuteBarsEndTimeUTC = lastCompleteMinuteUTC.toMillis(); 
                        if(lastCompleteMinuteUTC.toMillis() <= candleStartTimeUTC) {
                                minuteBarsEndTimeUTC = candleStartTimeUTC;
                        }
                        const minuteBarsDurationMs = minuteBarsEndTimeUTC - referenceStartTime; 
                        console.log("minuteBarsEndTime", minuteBarsEndTimeUTC)
                        console.log("referenceStartTime", referenceStartTime)
                        const numMinuteBars = Math.floor(minuteBarsDurationMs / (60*1000))
                        console.log('numMinuteBars', numMinuteBars)
                        let minuteBarsPromise: Promise<BarData[]> = Promise.resolve([]);

                        if(numMinuteBars > 0) {
                                minuteBarsPromise = privateRequest<BarData[]>("getChartData", {
                                    securityId: inst.securityId,
                                    timeframe: "1",
                                    timestamp: referenceStartTime,
                                    direction: "forward",
                                    bars: numMinuteBars, 
                                    extendedhours: inst.extendedHours, 
                                    isreplay: false,
                                });
                        }
                        const tickDataStartTimeUTC = minuteBarsEndTimeUTC; 
                        const tickDataDurationMs = UTCSecondstoESTSeconds(now/1000)*1000 - tickDataStartTimeUTC; 
                        let tickDataPromise: Promise<TradeData[]> = Promise.resolve([]);
                        if(tickDataDurationMs >0) {
                            tickDataPromise = privateRequest<TradeData[]>("getTradeData", {
                                securityId: inst.securityId,
                                time: tickDataStartTimeUTC, 
                                lengthOfTime: Math.floor(tickDataDurationMs), 
                                extendedHours: inst.extendedHours,
                            });
                        }
                        Promise.all([dailyBarsPromise, minuteBarsPromise, tickDataPromise]).then(([dailyBars, minuteBars, tickData]) => {
                            const allPrices: number[] = [];
                            if(dailyBars && dailyBars.length > 0) {
                                const filteredDailyBars = dailyBars.filter(bar => bar.time*1000 < dayBarsEndTimeUTC);
                                if(filteredDailyBars && filteredDailyBars.length > 0) {
                                    console.log("daily bar:", filteredDailyBars[0].time, dayBarsEndTimeUTC)
                                    aggregateOpen = filteredDailyBars[0].open;
                                    aggregateClose = filteredDailyBars[filteredDailyBars.length-1].close;
                                    filteredDailyBars.forEach(bar => {
                                        allPrices.push(bar.high, bar.low)
                                })
                                }
                            }
                            if(minuteBars && minuteBars.length >0) {
                                console.log(minuteBars)
                                if(aggregateOpen === undefined) {
                                    aggregateOpen = minuteBars[0].open;
                                }
                                aggregateClose = minuteBars[minuteBars.length-1].close;
                                minuteBars.forEach(bar => {
                                    allPrices.push(bar.high, bar.low)
                                })
                            }
                            if(tickData && tickData.length > 0) {
                                const filteredTickData = tickData.filter(tick => tick.size >= 100);

                                if (filteredTickData.length > 0) {
                                    const tickPrices = filteredTickData.map(tick => tick.price);
                                    allPrices.push(...tickPrices);

                                    if (aggregateOpen === undefined) {
                                        aggregateOpen = tickPrices[0];
                                    }
                                    aggregateClose = tickPrices[tickPrices.length - 1];
                                }
                            } 
                            if(allPrices.length > 0 && aggregateOpen !== undefined && aggregateClose !== undefined) {
                                aggregateHigh = Math.max(...allPrices);
                                aggregateLow = Math.min(...allPrices);
                                console.log({
                                    time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                    open: aggregateOpen, 
                                    high: aggregateHigh,
                                    low: aggregateLow,
                                    close: aggregateClose,
                                })
                                if(candleStartTimeUTC > lastBarTimeMs) {
                                    newCandleData.push({
                                    time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                    open: aggregateOpen, 
                                    high: aggregateHigh,
                                    low: aggregateLow,
                                    close: aggregateClose,
                                    })
                                    console.log("push time", Date.now())
                                    if(queuedLoad) {
                                        queuedLoad()
                                    }
                                }
                                else {
                                    newCandleData[newCandleData.length-1] = {
                                    time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                    open: aggregateOpen, 
                                    high: aggregateHigh,
                                    low: aggregateLow,
                                    close: aggregateClose,
                                    }
                                    console.log(newCandleData[newCandleData.length-1])
                                    if(queuedLoad) {
                                        queuedLoad()
                                    }
                                }
                            } 
                            else {
                                console.log("No data returned for aggregation.")
                                if(queuedLoad) {
                                    queuedLoad()
                                }
                            }
                        }).catch(error => {
                            if(queuedLoad) {
                                queuedLoad()
                            }
                        })
                    }
                    else if(inst.timeframe?.includes('w')) {
                        const referenceDateTime = DateTime.fromObject({year:2003, month:9, day:8, minute:0, second:0, millisecond:0,}, {zone: 'America/New_York'});
                        const now = getRealTimeTime()
                        const nowDateTime = DateTime.fromMillis(now)
                        const elapsedTimeInWeeks = nowDateTime.diff(referenceDateTime, 'weeks').weeks;
                        const numFullBars = Math.floor(elapsedTimeInWeeks / parseInt(inst.timeframe));
                        const candleStartDateTime = referenceDateTime.plus({ weeks: numFullBars * parseInt(inst.timeframe) });

                        // Candle start time in UTC milliseconds
                        const candleStartTimeUTC = candleStartDateTime.toUTC().toMillis();
                        referenceStartTime = getReferenceStartTimeForDateMilliseconds(now, false) // market open time of the day
                        console.log("candleStartTime:", candleStartTimeUTC)
                        const lastBar = newCandleData[newCandleData.length - 1];
                        const lastBarTimeMs = ESTSecondstoUTCMillis(lastBar.time); 

                        const lastCompleteDayUTC = DateTime.fromMillis(UTCSecondstoESTSeconds(now/1000)*1000).startOf('day')
                        let dayBarsEndTimeUTC = lastCompleteDayUTC.toMillis();
                        if(dayBarsEndTimeUTC <= candleStartTimeUTC) {
                            dayBarsEndTimeUTC = candleStartTimeUTC;
                        }
                        const dailyBarsDurationMs = dayBarsEndTimeUTC - candleStartTimeUTC; 
                        console.log("dailyBarsDurationMs", dailyBarsDurationMs)
                        const numDailyBars = Math.floor(dailyBarsDurationMs / (86400000))
                        console.log('numDailyBars', numDailyBars)
                        let dailyBarsPromise: Promise<BarData[]> = Promise.resolve([]);
                        if(numDailyBars > 0) {
                            dailyBarsPromise = privateRequest<BarData[]>("getChartData", {
                                securityId: inst.securityId,
                                timeframe: "1d",
                                timestamp: candleStartTimeUTC, 
                                direction: "forward",
                                bars: numDailyBars, 
                                extendedhours: false, 
                                isreplay: true,
                            })
                        }
                        const lastCompleteMinuteUTC = DateTime.fromMillis(UTCSecondstoESTSeconds(now/1000)*1000).startOf('minute')
                        let minuteBarsEndTimeUTC = lastCompleteMinuteUTC.toMillis(); 
                        if(lastCompleteMinuteUTC.toMillis() <= candleStartTimeUTC) {
                                minuteBarsEndTimeUTC = candleStartTimeUTC;
                        }
                        const minuteBarsDurationMs = minuteBarsEndTimeUTC - referenceStartTime; 
                        console.log("minuteBarsEndTime", minuteBarsEndTimeUTC)
                        console.log("referenceStartTime", referenceStartTime)
                        const numMinuteBars = Math.floor(minuteBarsDurationMs / (60*1000))
                        console.log('numMinuteBars', numMinuteBars)
                        let minuteBarsPromise: Promise<BarData[]> = Promise.resolve([]);

                        if(numMinuteBars > 0) {
                                minuteBarsPromise = privateRequest<BarData[]>("getChartData", {
                                    securityId: inst.securityId,
                                    timeframe: "1",
                                    timestamp: referenceStartTime,
                                    direction: "forward",
                                    bars: numMinuteBars, 
                                    extendedhours: inst.extendedHours, 
                                    isreplay: false,
                                });
                        }
                        const tickDataStartTimeUTC = minuteBarsEndTimeUTC; 
                        const tickDataDurationMs = UTCSecondstoESTSeconds(now/1000)*1000 - tickDataStartTimeUTC; 
                        let tickDataPromise: Promise<TradeData[]> = Promise.resolve([]);
                        if(tickDataDurationMs >0) {
                            tickDataPromise = privateRequest<TradeData[]>("getTradeData", {
                                securityId: inst.securityId,
                                time: tickDataStartTimeUTC, 
                                lengthOfTime: Math.floor(tickDataDurationMs), 
                                extendedHours: inst.extendedHours,
                            });
                        }
                        Promise.all([dailyBarsPromise, minuteBarsPromise, tickDataPromise]).then(([dailyBars, minuteBars, tickData]) => {
                            const allPrices: number[] = [];
                            if(dailyBars && dailyBars.length > 0) {
                                const filteredDailyBars = dailyBars.filter(bar => bar.time*1000 < dayBarsEndTimeUTC);
                                if(filteredDailyBars && filteredDailyBars.length > 0) {
                                    console.log("daily bar:", filteredDailyBars[0].time, dayBarsEndTimeUTC)
                                    aggregateOpen = filteredDailyBars[0].open;
                                    aggregateClose = filteredDailyBars[filteredDailyBars.length-1].close;
                                    filteredDailyBars.forEach(bar => {
                                        allPrices.push(bar.high, bar.low)
                                })
                                }
                            }
                            if(minuteBars && minuteBars.length >0) {
                                console.log(minuteBars)
                                if(aggregateOpen === undefined) {
                                    aggregateOpen = minuteBars[0].open;
                                }
                                aggregateClose = minuteBars[minuteBars.length-1].close;
                                minuteBars.forEach(bar => {
                                    allPrices.push(bar.high, bar.low)
                                })
                            }
                            if(tickData && tickData.length > 0) {
                                const filteredTickData = tickData.filter(tick => tick.size >= 100);

                                if (filteredTickData.length > 0) {
                                    const tickPrices = filteredTickData.map(tick => tick.price);
                                    allPrices.push(...tickPrices);

                                    if (aggregateOpen === undefined) {
                                        aggregateOpen = tickPrices[0];
                                    }
                                    aggregateClose = tickPrices[tickPrices.length - 1];
                                }
                            } 
                            if(allPrices.length > 0 && aggregateOpen !== undefined && aggregateClose !== undefined) {
                                aggregateHigh = Math.max(...allPrices);
                                aggregateLow = Math.min(...allPrices);
                                console.log({
                                    time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                    open: aggregateOpen, 
                                    high: aggregateHigh,
                                    low: aggregateLow,
                                    close: aggregateClose,
                                })
                                if(candleStartTimeUTC > lastBarTimeMs) {
                                    newCandleData.push({
                                    time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                    open: aggregateOpen, 
                                    high: aggregateHigh,
                                    low: aggregateLow,
                                    close: aggregateClose,
                                    })
                                    console.log("push time", Date.now())
                                    if(queuedLoad) {
                                        queuedLoad()
                                    }
                                }
                                else {
                                    newCandleData[newCandleData.length-1] = {
                                    time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                    open: aggregateOpen, 
                                    high: aggregateHigh,
                                    low: aggregateLow,
                                    close: aggregateClose,
                                    }
                                    console.log(newCandleData[newCandleData.length-1])
                                    if(queuedLoad) {
                                        queuedLoad()
                                    }
                                }
                            } 
                            else {
                                console.log("No data returned for aggregation.")
                                if(queuedLoad) {
                                    queuedLoad()
                                }
                            }
                        }).catch(error => {
                            if(queuedLoad) {
                                queuedLoad()
                            }
                            console.error("Error fetching data for aggregation:", error)
                        })
                    }
                    else if(inst.timeframe?.includes('d')) {
                        let referenceDateTime; 
                        const now = getRealTimeTime()
                        if(parseInt(inst.timeframe) === 1) {
                            referenceDateTime = DateTime.fromObject({year:2003, month:9, day:10, minute:0, second:0, millisecond:0,}, {zone: 'America/New_York'});
                        } else {
                            referenceDateTime = DateTime.fromObject({year:2003, month:9, day:9, minute:0, second:0, millisecond:0,}, {zone: 'America/New_York'});
                        }
                        const nowDateTime = DateTime.fromMillis(now)
                        const elapsedTimeInDays = nowDateTime.diff(referenceDateTime, 'days').days;
                        const numFullBars = Math.floor(elapsedTimeInDays / parseInt(inst.timeframe));
                        const candleStartDateTime = referenceDateTime.plus({days: numFullBars * parseInt(inst.timeframe)});
                        const candleStartTimeUTC = candleStartDateTime.toUTC().toMillis();
                        referenceStartTime = getReferenceStartTimeForDateMilliseconds(now, false);
                        const lastBar = newCandleData[newCandleData.length-1]; 
                        const lastBarTimeMs = ESTSecondstoUTCMillis(lastBar.time);

                        const lastCompleteDayUTC = DateTime.fromMillis(UTCSecondstoESTSeconds(now/1000)*1000).startOf('day')
                        let dayBarsEndTimeUTC = lastCompleteDayUTC.toMillis();
                        if(dayBarsEndTimeUTC <= candleStartTimeUTC) {
                            dayBarsEndTimeUTC = candleStartTimeUTC;
                        }
                        const dailyBarsDurationMs = dayBarsEndTimeUTC - candleStartTimeUTC; 
                        console.log("dailyBarsDurationMs", dailyBarsDurationMs)
                        const numDailyBars = Math.floor(dailyBarsDurationMs / (86400000))
                        console.log('numDailyBars', numDailyBars)
                        let dailyBarsPromise: Promise<BarData[]> = Promise.resolve([]);
                        if(numDailyBars > 0) {
                            dailyBarsPromise = privateRequest<BarData[]>("getChartData", {
                                securityId: inst.securityId,
                                timeframe: "1d",
                                timestamp: candleStartTimeUTC, 
                                direction: "forward",
                                bars: numDailyBars, 
                                extendedhours: false, 
                                isreplay: false,
                            })
                        }
                        const lastCompleteMinuteUTC = DateTime.fromMillis(UTCSecondstoESTSeconds(now/1000)*1000).startOf('minute')
                        let minuteBarsEndTimeUTC = lastCompleteMinuteUTC.toMillis(); 
                        if(lastCompleteMinuteUTC.toMillis() <= candleStartTimeUTC) {
                                minuteBarsEndTimeUTC = candleStartTimeUTC;
                        }
                        const minuteBarsDurationMs = minuteBarsEndTimeUTC - referenceStartTime; 
                        console.log("minuteBarsEndTime", minuteBarsEndTimeUTC)
                        console.log("referenceStartTime", referenceStartTime)
                        const numMinuteBars = Math.floor(minuteBarsDurationMs / (60*1000))
                        console.log('numMinuteBars', numMinuteBars)
                        let minuteBarsPromise: Promise<BarData[]> = Promise.resolve([]);

                        if(numMinuteBars > 0) {
                                minuteBarsPromise = privateRequest<BarData[]>("getChartData", {
                                    securityId: inst.securityId,
                                    timeframe: "1",
                                    timestamp: referenceStartTime,
                                    direction: "forward",
                                    bars: numMinuteBars, 
                                    extendedhours: inst.extendedHours, 
                                    isreplay: true,
                                });
                        }
                        const tickDataStartTimeUTC = minuteBarsEndTimeUTC; 
                        const tickDataDurationMs = UTCSecondstoESTSeconds(now/1000)*1000 - tickDataStartTimeUTC; 
                        let tickDataPromise: Promise<TradeData[]> = Promise.resolve([]);
                        if(tickDataDurationMs >0) {
                            tickDataPromise = privateRequest<TradeData[]>("getTradeData", {
                                securityId: inst.securityId,
                                time: tickDataStartTimeUTC, 
                                lengthOfTime: Math.floor(tickDataDurationMs), 
                                extendedHours: inst.extendedHours,
                            });
                        }
                        Promise.all([dailyBarsPromise, minuteBarsPromise, tickDataPromise]).then(([dailyBars, minuteBars, tickData]) => {
                            const allPrices: number[] = [];
                            if(dailyBars && dailyBars.length > 0) {
                                const filteredDailyBars = dailyBars.filter(bar => bar.time*1000 < dayBarsEndTimeUTC);
                                if(filteredDailyBars && filteredDailyBars.length > 0) {
                                    console.log("daily bar:", filteredDailyBars[0].time, dayBarsEndTimeUTC)
                                    aggregateOpen = filteredDailyBars[0].open;
                                    aggregateClose = filteredDailyBars[filteredDailyBars.length-1].close;
                                    filteredDailyBars.forEach(bar => {
                                        allPrices.push(bar.high, bar.low)
                                })
                                }
                            }
                            if(minuteBars && minuteBars.length >0) {
                                console.log(minuteBars)
                                if(aggregateOpen === undefined) {
                                    aggregateOpen = minuteBars[0].open;
                                }
                                aggregateClose = minuteBars[minuteBars.length-1].close;
                                minuteBars.forEach(bar => {
                                    allPrices.push(bar.high, bar.low)
                                })
                            }
                            if(tickData && tickData.length > 0) {
                                const filteredTickData = tickData.filter(tick => tick.size >= 100);

                                if (filteredTickData.length > 0) {
                                    const tickPrices = filteredTickData.map(tick => tick.price);
                                    allPrices.push(...tickPrices);

                                    if (aggregateOpen === undefined) {
                                        aggregateOpen = tickPrices[0];
                                    }
                                    aggregateClose = tickPrices[tickPrices.length - 1];
                                }
                            } 
                            if(allPrices.length > 0 && aggregateOpen !== undefined && aggregateClose !== undefined) {
                                aggregateHigh = Math.max(...allPrices);
                                aggregateLow = Math.min(...allPrices);
                                console.log({
                                    time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                    open: aggregateOpen, 
                                    high: aggregateHigh,
                                    low: aggregateLow,
                                    close: aggregateClose,
                                })
                                if(candleStartTimeUTC > lastBarTimeMs) {
                                    newCandleData.push({
                                    time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                    open: aggregateOpen, 
                                    high: aggregateHigh,
                                    low: aggregateLow,
                                    close: aggregateClose,
                                    })
                                    console.log("push time", Date.now())
                                    if(queuedLoad) {
                                        queuedLoad()
                                    }
                                }
                                else {
                                    newCandleData[newCandleData.length-1] = {
                                    time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                    open: aggregateOpen, 
                                    high: aggregateHigh,
                                    low: aggregateLow,
                                    close: aggregateClose,
                                    }
                                    console.log(newCandleData[newCandleData.length-1])
                                    if(queuedLoad) {
                                        queuedLoad()
                                    }
                                }
                            } 
                            else {
                                console.log("No data returned for aggregation.")
                                if(queuedLoad) {
                                    queuedLoad()
                                }
                            }
                        }).catch(error => {
                            if(queuedLoad) {
                                queuedLoad()
                            }
                        })

                        
                    }
                    else if(inst.timeframe?.includes('s')) {
                        const now = getRealTimeTime()
                        referenceStartTime =  getReferenceStartTimeForDateMilliseconds(newCandleData[newCandleData.length-1].time*1000, inst.extendedHours)
                        console.log("Current timestamp:", now)
                        const elapsedTime = now - referenceStartTime; 
                        console.log("elapsed time is:", elapsedTime)
                        if(elapsedTime < 0) {
                            console.log("Trading session has not started yet.")
                            queuedLoad()
                        } 
                        else {
                            const timeframeMs = chartTimeframeInSeconds * 1000; 
                            const numFullBars = Math.floor(elapsedTime / timeframeMs);
                            const candleStartTimeUTC = referenceStartTime + numFullBars*timeframeMs;
                            console.log("Candle Start Time UTC:", candleStartTimeUTC)
                            const lastBar = newCandleData[newCandleData.length - 1];
                            const lastBarTimeMs = ESTSecondstoUTCMillis(lastBar.time); 

                            const lastCompleteSecondUTC = DateTime.fromMillis(now, {zone: 'utc'}).startOf('second')
                            let secondBarsEndTimeUTC = lastCompleteSecondUTC.toMillis();
                            if(lastCompleteSecondUTC.toMillis() <= candleStartTimeUTC) {
                                secondBarsEndTimeUTC = candleStartTimeUTC;
                            }
                            const secondBarsDurationMs = secondBarsEndTimeUTC - candleStartTimeUTC;
                            console.log("secondBarsDurationMs", secondBarsDurationMs)
                            const numSecondBars = Math.floor(secondBarsDurationMs / (1000))
                            let secondBarsPromise: Promise<BarData[]> = Promise.resolve([]);
                            console.log("numSecondBars:", numSecondBars)
                            if(numSecondBars > 0) {
                                secondBarsPromise = privateRequest<BarData[]>("getChartData", {
                                    securityId: inst.securityId,
                                    timeframe: "1s",
                                    timestamp: candleStartTimeUTC,
                                    direction: "forward",
                                    bars: numSecondBars, 
                                    extendedhours: inst.extendedHours, 
                                    isreplay: (get(replayInfo).status === "active" || get(replayInfo).status === "paused"),
                                });
                            }
                            const tickDataStartTimeUTC = secondBarsEndTimeUTC; 
                            const tickDataDurationMs = UTCSecondstoESTSeconds(now/1000)*1000 - tickDataStartTimeUTC; 
                            let tickDataPromise: Promise<TradeData[]> = Promise.resolve([]);
                            if(tickDataDurationMs >0) {
                                tickDataPromise = privateRequest<TradeData[]>("getTradeData", {
                                    securityId: inst.securityId,
                                    time: tickDataStartTimeUTC, 
                                    lengthOfTime: tickDataDurationMs, 
                                    extendedHours: inst.extendedHours,
                                });
                            }
                            Promise.all([secondBarsPromise, tickDataPromise]).then(([secondBars, tickData]) => {
                                const allPrices: number[] = [];
                                if(secondBars && secondBars.length >0) {
                                    console.log(secondBars)
                                    aggregateOpen = secondBars[0].open;
                                    aggregateClose = secondBars[secondBars.length-1].close;
                                    secondBars.forEach(bar => {
                                        allPrices.push(bar.high, bar.low)
                                    })
                                }
                                if(tickData && tickData.length > 0) {
                                    const filteredTickData = tickData.filter(tick => tick.size >= 100);

                                    if (filteredTickData.length > 0) {
                                        const tickPrices = filteredTickData.map(tick => tick.price);
                                        allPrices.push(...tickPrices);

                                        if (aggregateOpen === undefined) {
                                            aggregateOpen = tickPrices[0];
                                        }
                                        aggregateClose = tickPrices[tickPrices.length - 1];
                                    }
                                } 
                                if(allPrices.length > 0 && aggregateOpen !== undefined && aggregateClose !== undefined) {
                                    aggregateHigh = Math.max(...allPrices);
                                    aggregateLow = Math.min(...allPrices);
                                    console.log({
                                        time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                        open: aggregateOpen, 
                                        high: aggregateHigh,
                                        low: aggregateLow,
                                        close: aggregateClose,
                                    })
                                    if(candleStartTimeUTC > lastBarTimeMs) {
                                        newCandleData.push({
                                        time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                        open: aggregateOpen, 
                                        high: aggregateHigh,
                                        low: aggregateLow,
                                        close: aggregateClose,
                                        })
                                        console.log("push time", Date.now())
                                        if(queuedLoad) {
                                            queuedLoad()
                                        }
                                    }
                                    else {
                                        newCandleData[newCandleData.length-1] = {
                                        time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                        open: aggregateOpen, 
                                        high: aggregateHigh,
                                        low: aggregateLow,
                                        close: aggregateClose,
                                        }
                                        if(queuedLoad) {
                                            queuedLoad()
                                        }
                                    }
                                } 
                                else {
                                    console.log("No data returned for aggregation.")
                                    if(queuedLoad) {
                                        queuedLoad()
                                    }
                                }
                            }).catch(error => {
                                if(queuedLoad) {
                                    queuedLoad()
                                }
                            })
                        }
                    }
                    else { // minute data OR HOURLY 
                        referenceStartTime =  getReferenceStartTimeForDateMilliseconds(newCandleData[newCandleData.length-1].time*1000, inst.extendedHours)
                        
                        const now = getRealTimeTime(); 
                        const elapsedTime = now - referenceStartTime; 
                        console.log("elapsed time is:", elapsedTime)
                        if(elapsedTime < 0 || (elapsedTime >= 57600000 && inst.extendedHours) || (elapsedTime >= 23400000 && !inst.extendedHours)) {
                            console.log("Trading session has not started yet.")
                            queuedLoad()
                        } 
                        else {
                            const timeframeMs = chartTimeframeInSeconds * 1000; 
                            const numFullBars = Math.floor(elapsedTime / timeframeMs);
                            const candleStartTimeUTC = referenceStartTime + numFullBars*timeframeMs;
                            console.log("Candle Start Time UTC:", candleStartTimeUTC)
                            const lastBar = newCandleData[newCandleData.length - 1];
                            const lastBarTimeMs = ESTSecondstoUTCMillis(lastBar.time); 

                            const lastCompleteMinuteUTC = DateTime.utc().startOf('minute')
                            let minuteBarsEndTimeUTC = lastCompleteMinuteUTC.toMillis();
                            if(lastCompleteMinuteUTC.toMillis() <= candleStartTimeUTC) {
                                minuteBarsEndTimeUTC = candleStartTimeUTC;
                            }
                            const minuteBarsDurationMs = minuteBarsEndTimeUTC - candleStartTimeUTC;
                            console.log("minuteBarsDurationMs", minuteBarsDurationMs)
                            const numMinuteBars = Math.floor(minuteBarsDurationMs / (60*1000))
                            let minuteBarsPromise: Promise<BarData[]> = Promise.resolve([]);
                            if(numMinuteBars > 0) {
                                minuteBarsPromise = privateRequest<BarData[]>("getChartData", {
                                    securityId: inst.securityId,
                                    timeframe: "1",
                                    timestamp: candleStartTimeUTC,
                                    direction: "forward",
                                    bars: numMinuteBars, 
                                    extendedhours: inst.extendedHours, 
                                    isreplay: (get(replayInfo).status === "active" || get(replayInfo).status === "paused"),
                                });
                            }
                            const tickDataStartTimeUTC = minuteBarsEndTimeUTC; 
                            const tickDataDurationMs = UTCSecondstoESTSeconds(now/1000)*1000 - tickDataStartTimeUTC; 
                            let tickDataPromise: Promise<TradeData[]> = Promise.resolve([]);
                            if(tickDataDurationMs >0) {
                                tickDataPromise = privateRequest<TradeData[]>("getTradeData", {
                                    securityId: inst.securityId,
                                    time: tickDataStartTimeUTC, 
                                    lengthOfTime: tickDataDurationMs, 
                                    extendedHours: inst.extendedHours,
                                });
                            }
                            Promise.all([minuteBarsPromise, tickDataPromise]).then(([minuteBars, tickData]) => {
                                const allPrices: number[] = [];
                                if(minuteBars && minuteBars.length >0) {
                                    console.log(minuteBars)
                                    aggregateOpen = minuteBars[0].open;
                                    aggregateClose = minuteBars[minuteBars.length-1].close;
                                    minuteBars.forEach(bar => {
                                        allPrices.push(bar.high, bar.low)
                                    })
                                }
                                if(tickData && tickData.length > 0) {
                                    const filteredTickData = tickData.filter(tick => tick.size >= 100);

                                    if (filteredTickData.length > 0) {
                                        const tickPrices = filteredTickData.map(tick => tick.price);
                                        allPrices.push(...tickPrices);

                                        if (aggregateOpen === undefined) {
                                            aggregateOpen = tickPrices[0];
                                        }
                                        aggregateClose = tickPrices[tickPrices.length - 1];
                                    }
                                } 
                                if(allPrices.length > 0 && aggregateOpen !== undefined && aggregateClose !== undefined) {
                                    aggregateHigh = Math.max(...allPrices);
                                    aggregateLow = Math.min(...allPrices);
                                    console.log(allPrices)
                                    console.log({
                                        time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                        open: aggregateOpen, 
                                        high: aggregateHigh,
                                        low: aggregateLow,
                                        close: aggregateClose,
                                    })
                                    if(candleStartTimeUTC > lastBarTimeMs) {
                                        newCandleData.push({
                                        time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                        open: aggregateOpen, 
                                        high: aggregateHigh,
                                        low: aggregateLow,
                                        close: aggregateClose,
                                        })
                                        console.log("push time", Date.now())
                                        if(queuedLoad) {
                                            queuedLoad()
                                        }
                                    }
                                    else {
                                        newCandleData[newCandleData.length-1] = {
                                        time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                        open: aggregateOpen, 
                                        high: aggregateHigh,
                                        low: aggregateLow,
                                        close: aggregateClose,
                                        }
                                        if(queuedLoad) {
                                            queuedLoad()
                                        }
                                    }
                                } 
                                else {
                                    console.log("No data returned for aggregation.")
                                    if(queuedLoad) {
                                        queuedLoad()
                                    }
                                }
                            }).catch(error => {
                                if(queuedLoad) {
                                    queuedLoad()
                                }
                            })
                        }
                    }

                }

                else if ((get(replayInfo).status == "active" || get(replayInfo).status == "paused")) { // should add more logic here to not include replay backloads in this
                    const now = get(currentTimestamp)
                    if(inst.timeframe?.includes('s')) {
                        referenceStartTime =  getReferenceStartTimeForDateMilliseconds(newCandleData[newCandleData.length-1].time*1000, inst.extendedHours)
                        console.log("Current timestamp:", now)
                        const elapsedTime = now - referenceStartTime; 
                        console.log("elapsed time is:", elapsedTime)
                        if(elapsedTime < 0) {
                            console.log("Trading session has not started yet.")
                            queuedLoad()
                        } 
                        else {
                            const timeframeMs = chartTimeframeInSeconds * 1000; 
                            const numFullBars = Math.floor(elapsedTime / timeframeMs);
                            const candleStartTimeUTC = referenceStartTime + numFullBars*timeframeMs;
                            console.log("Candle Start Time UTC:", candleStartTimeUTC)
                            const lastBar = newCandleData[newCandleData.length - 1];
                            const lastBarTimeMs = ESTSecondstoUTCMillis(lastBar.time); 

                            const lastCompleteSecondUTC = DateTime.fromMillis(now, {zone: 'utc'}).startOf('second')
                            let secondBarsEndTimeUTC = lastCompleteSecondUTC.toMillis();
                            if(lastCompleteSecondUTC.toMillis() <= candleStartTimeUTC) {
                                secondBarsEndTimeUTC = candleStartTimeUTC;
                            }
                            const secondBarsDurationMs = secondBarsEndTimeUTC - candleStartTimeUTC;
                            console.log("secondBarsDurationMs", secondBarsDurationMs)
                            const numSecondBars = Math.floor(secondBarsDurationMs / (1000))
                            let secondBarsPromise: Promise<BarData[]> = Promise.resolve([]);
                            console.log("numSecondBars:", numSecondBars)
                            if(numSecondBars > 0) {
                                secondBarsPromise = privateRequest<BarData[]>("getChartData", {
                                    securityId: inst.securityId,
                                    timeframe: "1s",
                                    timestamp: candleStartTimeUTC,
                                    direction: "forward",
                                    bars: numSecondBars, 
                                    extendedhours: inst.extendedHours, 
                                    isreplay: (get(replayInfo).status === "active" || get(replayInfo).status === "paused"),
                                });
                            }
                            const tickDataStartTimeUTC = secondBarsEndTimeUTC; 
                            const tickDataDurationMs = UTCSecondstoESTSeconds(now/1000)*1000 - tickDataStartTimeUTC; 
                            let tickDataPromise: Promise<TradeData[]> = Promise.resolve([]);
                            if(tickDataDurationMs >0) {
                                tickDataPromise = privateRequest<TradeData[]>("getTradeData", {
                                    securityId: inst.securityId,
                                    time: tickDataStartTimeUTC, 
                                    lengthOfTime: tickDataDurationMs, 
                                    extendedHours: inst.extendedHours,
                                });
                            }
                            Promise.all([secondBarsPromise, tickDataPromise]).then(([secondBars, tickData]) => {
                                const allPrices: number[] = [];
                                if(secondBars && secondBars.length >0) {
                                    console.log(secondBars)
                                    aggregateOpen = secondBars[0].open;
                                    aggregateClose = secondBars[secondBars.length-1].close;
                                    secondBars.forEach(bar => {
                                        allPrices.push(bar.high, bar.low)
                                    })
                                }
                                if(tickData && tickData.length > 0) {
                                    const filteredTickData = tickData.filter(tick => tick.size >= 100);

                                    if (filteredTickData.length > 0) {
                                        const tickPrices = filteredTickData.map(tick => tick.price);
                                        allPrices.push(...tickPrices);

                                        if (aggregateOpen === undefined) {
                                            aggregateOpen = tickPrices[0];
                                        }
                                        aggregateClose = tickPrices[tickPrices.length - 1];
                                    }
                                } 
                                if(allPrices.length > 0 && aggregateOpen !== undefined && aggregateClose !== undefined) {
                                    aggregateHigh = Math.max(...allPrices);
                                    aggregateLow = Math.min(...allPrices);
                                    console.log({
                                        time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                        open: aggregateOpen, 
                                        high: aggregateHigh,
                                        low: aggregateLow,
                                        close: aggregateClose,
                                    })
                                    if(candleStartTimeUTC > lastBarTimeMs) {
                                        newCandleData.push({
                                        time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                        open: aggregateOpen, 
                                        high: aggregateHigh,
                                        low: aggregateLow,
                                        close: aggregateClose,
                                        })
                                        console.log("push time", Date.now())
                                        if(queuedLoad) {
                                            queuedLoad()
                                        }
                                    }
                                    else {
                                        newCandleData[newCandleData.length-1] = {
                                        time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                        open: aggregateOpen, 
                                        high: aggregateHigh,
                                        low: aggregateLow,
                                        close: aggregateClose,
                                        }
                                        if(queuedLoad) {
                                            queuedLoad()
                                        }
                                    }
                                } 
                                else {
                                    console.log("No data returned for aggregation.")
                                    if(queuedLoad) {
                                        queuedLoad()
                                    }
                                }
                            }).catch(error => {
                                console.error("Error fetching data for aggregation:", error)
                            })
                        }
                    }
                    else if(inst.timeframe?.includes('m')) {
                        const referenceDateTime = DateTime.fromObject({year:2003, month:9, day:1, minute:0, second:0, millisecond:0,}, {zone: 'America/New_York'});
                        const nowDateTime = DateTime.fromMillis(now)
                        const elapsedTimeInMonths = nowDateTime.diff(referenceDateTime, 'months').months;
                        const numFullBars = Math.floor(elapsedTimeInMonths / parseInt(inst.timeframe));
                        const candleStartDateTime = referenceDateTime.plus({ months: numFullBars * parseInt(inst.timeframe) });

                        const candleStartTimeUTC = candleStartDateTime.toUTC().toMillis();
                        referenceStartTime = getReferenceStartTimeForDateMilliseconds(now, false) // market open time of the day
                        console.log("candleStartTime:", candleStartTimeUTC)
                        const lastBar = newCandleData[newCandleData.length - 1];
                        const lastBarTimeMs = ESTSecondstoUTCMillis(lastBar.time); 
                        const lastCompleteDayUTC = DateTime.fromMillis(UTCSecondstoESTSeconds(now/1000)*1000).startOf('day')
                        let dayBarsEndTimeUTC = lastCompleteDayUTC.toMillis();
                        if(dayBarsEndTimeUTC <= candleStartTimeUTC) {
                            dayBarsEndTimeUTC = candleStartTimeUTC;
                        }
                        const dailyBarsDurationMs = dayBarsEndTimeUTC - candleStartTimeUTC; 
                        console.log("dailyBarsDurationMs", dailyBarsDurationMs)
                        const numDailyBars = Math.floor(dailyBarsDurationMs / (86400000))
                        console.log('numDailyBars', numDailyBars)
                        let dailyBarsPromise: Promise<BarData[]> = Promise.resolve([]);
                        if(numDailyBars > 0) {
                            dailyBarsPromise = privateRequest<BarData[]>("getChartData", {
                                securityId: inst.securityId,
                                timeframe: "1d",
                                timestamp: candleStartTimeUTC, 
                                direction: "forward",
                                bars: numDailyBars, 
                                extendedhours: false, 
                                isreplay: true,
                            })
                        }
                        const lastCompleteMinuteUTC = DateTime.fromMillis(UTCSecondstoESTSeconds(now/1000)*1000).startOf('minute')
                        let minuteBarsEndTimeUTC = lastCompleteMinuteUTC.toMillis(); 
                        if(lastCompleteMinuteUTC.toMillis() <= candleStartTimeUTC) {
                                minuteBarsEndTimeUTC = candleStartTimeUTC;
                        }
                        const minuteBarsDurationMs = minuteBarsEndTimeUTC - referenceStartTime; 
                        console.log("minuteBarsEndTime", minuteBarsEndTimeUTC)
                        console.log("referenceStartTime", referenceStartTime)
                        const numMinuteBars = Math.floor(minuteBarsDurationMs / (60*1000))
                        console.log('numMinuteBars', numMinuteBars)
                        let minuteBarsPromise: Promise<BarData[]> = Promise.resolve([]);

                        if(numMinuteBars > 0) {
                                minuteBarsPromise = privateRequest<BarData[]>("getChartData", {
                                    securityId: inst.securityId,
                                    timeframe: "1",
                                    timestamp: referenceStartTime,
                                    direction: "forward",
                                    bars: numMinuteBars, 
                                    extendedhours: false, 
                                    isreplay: true,
                                });
                        }
                        const tickDataStartTimeUTC = minuteBarsEndTimeUTC; 
                        const tickDataDurationMs = UTCSecondstoESTSeconds(now/1000)*1000 - tickDataStartTimeUTC; 
                        let tickDataPromise: Promise<TradeData[]> = Promise.resolve([]);
                        if(tickDataDurationMs >0) {
                            tickDataPromise = privateRequest<TradeData[]>("getTradeData", {
                                securityId: inst.securityId,
                                time: tickDataStartTimeUTC, 
                                lengthOfTime: Math.floor(tickDataDurationMs), 
                                extendedHours: false,
                            });
                        }
                        Promise.all([dailyBarsPromise, minuteBarsPromise, tickDataPromise]).then(([dailyBars, minuteBars, tickData]) => {
                            const allPrices: number[] = [];
                            if(dailyBars && dailyBars.length > 0) {
                                const filteredDailyBars = dailyBars.filter(bar => bar.time*1000 < dayBarsEndTimeUTC);
                                if(filteredDailyBars && filteredDailyBars.length > 0) {
                                    console.log("daily bar:", filteredDailyBars[0].time, dayBarsEndTimeUTC)
                                    aggregateOpen = filteredDailyBars[0].open;
                                    aggregateClose = filteredDailyBars[filteredDailyBars.length-1].close;
                                    filteredDailyBars.forEach(bar => {
                                        allPrices.push(bar.high, bar.low)
                                })
                                }
                            }
                            if(minuteBars && minuteBars.length >0) {
                                console.log(minuteBars)
                                if(aggregateOpen === undefined) {
                                    aggregateOpen = minuteBars[0].open;
                                }
                                aggregateClose = minuteBars[minuteBars.length-1].close;
                                minuteBars.forEach(bar => {
                                    allPrices.push(bar.high, bar.low)
                                })
                            }
                            if(tickData && tickData.length > 0) {
                                const filteredTickData = tickData.filter(tick => tick.size >= 100);

                                if (filteredTickData.length > 0) {
                                    const tickPrices = filteredTickData.map(tick => tick.price);
                                    allPrices.push(...tickPrices);

                                    if (aggregateOpen === undefined) {
                                        aggregateOpen = tickPrices[0];
                                    }
                                    aggregateClose = tickPrices[tickPrices.length - 1];
                                }
                            } 
                            if(allPrices.length > 0 && aggregateOpen !== undefined && aggregateClose !== undefined) {
                                aggregateHigh = Math.max(...allPrices);
                                aggregateLow = Math.min(...allPrices);
                                console.log({
                                    time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                    open: aggregateOpen, 
                                    high: aggregateHigh,
                                    low: aggregateLow,
                                    close: aggregateClose,
                                })
                                if(candleStartTimeUTC > lastBarTimeMs) {
                                    newCandleData.push({
                                    time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                    open: aggregateOpen, 
                                    high: aggregateHigh,
                                    low: aggregateLow,
                                    close: aggregateClose,
                                    })
                                    console.log("push time", Date.now())
                                    if(queuedLoad) {
                                        queuedLoad()
                                    }
                                }
                                else {
                                    newCandleData[newCandleData.length-1] = {
                                    time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                    open: aggregateOpen, 
                                    high: aggregateHigh,
                                    low: aggregateLow,
                                    close: aggregateClose,
                                    }
                                    console.log(newCandleData[newCandleData.length-1])
                                    if(queuedLoad) {
                                        queuedLoad()
                                    }
                                }
                            } 
                            else {
                                console.log("No data returned for aggregation.")
                                if(queuedLoad) {
                                    queuedLoad()
                                }
                            }
                        }).catch(error => {
                            console.error("Error fetching data for aggregation:", error)
                        })
                        
                    }
                    else if (inst.timeframe?.includes('w')) {
                        const referenceDateTime = DateTime.fromObject({year:2003, month:9, day:8, minute:0, second:0, millisecond:0,}, {zone: 'America/New_York'});
                        const nowDateTime = DateTime.fromMillis(now)
                        const elapsedTimeInWeeks = nowDateTime.diff(referenceDateTime, 'weeks').weeks;
                        const numFullBars = Math.floor(elapsedTimeInWeeks / parseInt(inst.timeframe));
                        const candleStartDateTime = referenceDateTime.plus({ weeks: numFullBars * parseInt(inst.timeframe) });

                        // Candle start time in UTC milliseconds
                        const candleStartTimeUTC = candleStartDateTime.toUTC().toMillis();
                        referenceStartTime = getReferenceStartTimeForDateMilliseconds(now, false) // market open time of the day
                        console.log("candleStartTime:", candleStartTimeUTC)
                        const lastBar = newCandleData[newCandleData.length - 1];
                        const lastBarTimeMs = ESTSecondstoUTCMillis(lastBar.time); 

                        const lastCompleteDayUTC = DateTime.fromMillis(UTCSecondstoESTSeconds(now/1000)*1000).startOf('day')
                        let dayBarsEndTimeUTC = lastCompleteDayUTC.toMillis();
                        if(dayBarsEndTimeUTC <= candleStartTimeUTC) {
                            dayBarsEndTimeUTC = candleStartTimeUTC;
                        }
                        const dailyBarsDurationMs = dayBarsEndTimeUTC - candleStartTimeUTC; 
                        console.log("dailyBarsDurationMs", dailyBarsDurationMs)
                        const numDailyBars = Math.floor(dailyBarsDurationMs / (86400000))
                        console.log('numDailyBars', numDailyBars)
                        let dailyBarsPromise: Promise<BarData[]> = Promise.resolve([]);
                        if(numDailyBars > 0) {
                            dailyBarsPromise = privateRequest<BarData[]>("getChartData", {
                                securityId: inst.securityId,
                                timeframe: "1d",
                                timestamp: candleStartTimeUTC, 
                                direction: "forward",
                                bars: numDailyBars, 
                                extendedhours: false, 
                                isreplay: true,
                            })
                        }
                        const lastCompleteMinuteUTC = DateTime.fromMillis(UTCSecondstoESTSeconds(now/1000)*1000).startOf('minute')
                        let minuteBarsEndTimeUTC = lastCompleteMinuteUTC.toMillis(); 
                        if(lastCompleteMinuteUTC.toMillis() <= candleStartTimeUTC) {
                                minuteBarsEndTimeUTC = candleStartTimeUTC;
                        }
                        const minuteBarsDurationMs = minuteBarsEndTimeUTC - referenceStartTime; 
                        console.log("minuteBarsEndTime", minuteBarsEndTimeUTC)
                        console.log("referenceStartTime", referenceStartTime)
                        const numMinuteBars = Math.floor(minuteBarsDurationMs / (60*1000))
                        console.log('numMinuteBars', numMinuteBars)
                        let minuteBarsPromise: Promise<BarData[]> = Promise.resolve([]);

                        if(numMinuteBars > 0) {
                                minuteBarsPromise = privateRequest<BarData[]>("getChartData", {
                                    securityId: inst.securityId,
                                    timeframe: "1",
                                    timestamp: referenceStartTime,
                                    direction: "forward",
                                    bars: numMinuteBars, 
                                    extendedhours: false, 
                                    isreplay: true,
                                });
                        }
                        const tickDataStartTimeUTC = minuteBarsEndTimeUTC; 
                        const tickDataDurationMs = UTCSecondstoESTSeconds(now/1000)*1000 - tickDataStartTimeUTC; 
                        let tickDataPromise: Promise<TradeData[]> = Promise.resolve([]);
                        if(tickDataDurationMs >0) {
                            tickDataPromise = privateRequest<TradeData[]>("getTradeData", {
                                securityId: inst.securityId,
                                time: tickDataStartTimeUTC, 
                                lengthOfTime: Math.floor(tickDataDurationMs), 
                                extendedHours: false,
                            });
                        }
                        Promise.all([dailyBarsPromise, minuteBarsPromise, tickDataPromise]).then(([dailyBars, minuteBars, tickData]) => {
                            const allPrices: number[] = [];
                            if(dailyBars && dailyBars.length > 0) {
                                const filteredDailyBars = dailyBars.filter(bar => bar.time*1000 < dayBarsEndTimeUTC);
                                if(filteredDailyBars && filteredDailyBars.length > 0) {
                                    console.log("daily bar:", filteredDailyBars[0].time, dayBarsEndTimeUTC)
                                    aggregateOpen = filteredDailyBars[0].open;
                                    aggregateClose = filteredDailyBars[filteredDailyBars.length-1].close;
                                    filteredDailyBars.forEach(bar => {
                                        allPrices.push(bar.high, bar.low)
                                })
                                }
                            }
                            if(minuteBars && minuteBars.length >0) {
                                console.log(minuteBars)
                                if(aggregateOpen === undefined) {
                                    aggregateOpen = minuteBars[0].open;
                                }
                                aggregateClose = minuteBars[minuteBars.length-1].close;
                                minuteBars.forEach(bar => {
                                    allPrices.push(bar.high, bar.low)
                                })
                            }
                            if(tickData && tickData.length > 0) {
                                const filteredTickData = tickData.filter(tick => tick.size >= 100);

                                if (filteredTickData.length > 0) {
                                    const tickPrices = filteredTickData.map(tick => tick.price);
                                    allPrices.push(...tickPrices);

                                    if (aggregateOpen === undefined) {
                                        aggregateOpen = tickPrices[0];
                                    }
                                    aggregateClose = tickPrices[tickPrices.length - 1];
                                }
                            } 
                            if(allPrices.length > 0 && aggregateOpen !== undefined && aggregateClose !== undefined) {
                                aggregateHigh = Math.max(...allPrices);
                                aggregateLow = Math.min(...allPrices);
                                console.log({
                                    time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                    open: aggregateOpen, 
                                    high: aggregateHigh,
                                    low: aggregateLow,
                                    close: aggregateClose,
                                })
                                if(candleStartTimeUTC > lastBarTimeMs) {
                                    newCandleData.push({
                                    time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                    open: aggregateOpen, 
                                    high: aggregateHigh,
                                    low: aggregateLow,
                                    close: aggregateClose,
                                    })
                                    console.log("push time", Date.now())
                                    if(queuedLoad) {
                                        queuedLoad()
                                    }
                                }
                                else {
                                    newCandleData[newCandleData.length-1] = {
                                    time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                    open: aggregateOpen, 
                                    high: aggregateHigh,
                                    low: aggregateLow,
                                    close: aggregateClose,
                                    }
                                    console.log(newCandleData[newCandleData.length-1])
                                    if(queuedLoad) {
                                        queuedLoad()
                                    }
                                }
                            } 
                            else {
                                console.log("No data returned for aggregation.")
                                if(queuedLoad) {
                                    queuedLoad()
                                }
                            }
                        }).catch(error => {
                            console.error("Error fetching data for aggregation:", error)
                        })
                        
                        
                    }
                    else if (inst.timeframe?.includes('d')) {
                        let referenceDateTime; 
                        if(parseInt(inst.timeframe) === 1) {
                            referenceDateTime = DateTime.fromObject({year:2003, month:9, day:10, minute:0, second:0, millisecond:0,}, {zone: 'America/New_York'});
                        } else {
                            referenceDateTime = DateTime.fromObject({year:2003, month:9, day:9, minute:0, second:0, millisecond:0,}, {zone: 'America/New_York'});
                        }
                        const nowDateTime = DateTime.fromMillis(now)
                        const elapsedTimeInDays = nowDateTime.diff(referenceDateTime, 'days').days;
                        const numFullBars = Math.floor(elapsedTimeInDays / parseInt(inst.timeframe));
                        const candleStartDateTime = referenceDateTime.plus({days: numFullBars * parseInt(inst.timeframe)});
                        const candleStartTimeUTC = candleStartDateTime.toUTC().toMillis();
                        referenceStartTime = getReferenceStartTimeForDateMilliseconds(now, false);
                        const lastBar = newCandleData[newCandleData.length-1]; 
                        const lastBarTimeMs = ESTSecondstoUTCMillis(lastBar.time);

                        const lastCompleteDayUTC = DateTime.fromMillis(UTCSecondstoESTSeconds(now/1000)*1000).startOf('day')
                        let dayBarsEndTimeUTC = lastCompleteDayUTC.toMillis();
                        if(dayBarsEndTimeUTC <= candleStartTimeUTC) {
                            dayBarsEndTimeUTC = candleStartTimeUTC;
                        }
                        const dailyBarsDurationMs = dayBarsEndTimeUTC - candleStartTimeUTC; 
                        console.log("dailyBarsDurationMs", dailyBarsDurationMs)
                        const numDailyBars = Math.floor(dailyBarsDurationMs / (86400000))
                        console.log('numDailyBars', numDailyBars)
                        let dailyBarsPromise: Promise<BarData[]> = Promise.resolve([]);
                        if(numDailyBars > 0) {
                            dailyBarsPromise = privateRequest<BarData[]>("getChartData", {
                                securityId: inst.securityId,
                                timeframe: "1d",
                                timestamp: candleStartTimeUTC, 
                                direction: "forward",
                                bars: numDailyBars, 
                                extendedhours: false, 
                                isreplay: true,
                            })
                        }
                        const lastCompleteMinuteUTC = DateTime.fromMillis(UTCSecondstoESTSeconds(now/1000)*1000).startOf('minute')
                        let minuteBarsEndTimeUTC = lastCompleteMinuteUTC.toMillis(); 
                        if(lastCompleteMinuteUTC.toMillis() <= candleStartTimeUTC) {
                                minuteBarsEndTimeUTC = candleStartTimeUTC;
                        }
                        const minuteBarsDurationMs = minuteBarsEndTimeUTC - referenceStartTime; 
                        console.log("minuteBarsEndTime", minuteBarsEndTimeUTC)
                        console.log("referenceStartTime", referenceStartTime)
                        const numMinuteBars = Math.floor(minuteBarsDurationMs / (60*1000))
                        console.log('numMinuteBars', numMinuteBars)
                        let minuteBarsPromise: Promise<BarData[]> = Promise.resolve([]);

                        if(numMinuteBars > 0) {
                                minuteBarsPromise = privateRequest<BarData[]>("getChartData", {
                                    securityId: inst.securityId,
                                    timeframe: "1",
                                    timestamp: referenceStartTime,
                                    direction: "forward",
                                    bars: numMinuteBars, 
                                    extendedhours: false, 
                                    isreplay: true,
                                });
                        }
                        const tickDataStartTimeUTC = minuteBarsEndTimeUTC; 
                        const tickDataDurationMs = UTCSecondstoESTSeconds(now/1000)*1000 - tickDataStartTimeUTC; 
                        let tickDataPromise: Promise<TradeData[]> = Promise.resolve([]);
                        if(tickDataDurationMs >0) {
                            tickDataPromise = privateRequest<TradeData[]>("getTradeData", {
                                securityId: inst.securityId,
                                time: tickDataStartTimeUTC, 
                                lengthOfTime: Math.floor(tickDataDurationMs), 
                                extendedHours: false,
                            });
                        }
                        console.log('Now', now)
                        console.log("numMinuteBars", numMinuteBars, "numTickSeconds", tickDataDurationMs)
                        Promise.all([dailyBarsPromise, minuteBarsPromise, tickDataPromise]).then(([dailyBars, minuteBars, tickData]) => {
                            const allPrices: number[] = [];
                            if(dailyBars && dailyBars.length > 0) {
                                const filteredDailyBars = dailyBars.filter(bar => bar.time*1000 < dayBarsEndTimeUTC);
                                if(filteredDailyBars && filteredDailyBars.length > 0) {
                                    console.log("daily bar:", filteredDailyBars[0].time, dayBarsEndTimeUTC)
                                    aggregateOpen = filteredDailyBars[0].open;
                                    aggregateClose = filteredDailyBars[filteredDailyBars.length-1].close;
                                    filteredDailyBars.forEach(bar => {
                                        allPrices.push(bar.high, bar.low)
                                })
                                }
                            }
                            if(minuteBars && minuteBars.length >0) {
                                console.log(minuteBars)
                                if(aggregateOpen === undefined) {
                                    aggregateOpen = minuteBars[0].open;
                                }
                                aggregateClose = minuteBars[minuteBars.length-1].close;
                                minuteBars.forEach(bar => {
                                    allPrices.push(bar.high, bar.low)
                                })
                            }
                            if(tickData && tickData.length > 0) {
                                const filteredTickData = tickData.filter(tick => tick.size >= 100);

                                if (filteredTickData.length > 0) {
                                    const tickPrices = filteredTickData.map(tick => tick.price);
                                    allPrices.push(...tickPrices);

                                    if (aggregateOpen === undefined) {
                                        aggregateOpen = tickPrices[0];
                                    }
                                    aggregateClose = tickPrices[tickPrices.length - 1];
                                }
                            } 
                            if(allPrices.length > 0 && aggregateOpen !== undefined && aggregateClose !== undefined) {
                                aggregateHigh = Math.max(...allPrices);
                                aggregateLow = Math.min(...allPrices);
                                console.log({
                                    time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                    open: aggregateOpen, 
                                    high: aggregateHigh,
                                    low: aggregateLow,
                                    close: aggregateClose,
                                })
                                if(candleStartTimeUTC > lastBarTimeMs) {
                                    newCandleData.push({
                                    time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                    open: aggregateOpen, 
                                    high: aggregateHigh,
                                    low: aggregateLow,
                                    close: aggregateClose,
                                    })
                                    console.log("push time", Date.now())
                                    if(queuedLoad) {
                                        queuedLoad()
                                    }
                                }
                                else {
                                    newCandleData[newCandleData.length-1] = {
                                    time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                    open: aggregateOpen, 
                                    high: aggregateHigh,
                                    low: aggregateLow,
                                    close: aggregateClose,
                                    }
                                    console.log(newCandleData[newCandleData.length-1])
                                    if(queuedLoad) {
                                        queuedLoad()
                                    }
                                }
                            } 
                            else {
                                console.log("No data returned for aggregation.")
                                if(queuedLoad) {
                                    queuedLoad()
                                }
                            }
                        }).catch(error => {
                            console.error("Error fetching data for aggregation:", error)
                        })
                    }
                    else { // minute data OR HOURLY 
                        referenceStartTime =  getReferenceStartTimeForDateMilliseconds(newCandleData[newCandleData.length-1].time*1000, inst.extendedHours)
                        console.log("Current timestamp:", now)
                        const elapsedTime = UTCSecondstoESTSeconds(now/1000)*1000 - referenceStartTime; 
                        console.log("elapsed time is:", elapsedTime)
                        if(elapsedTime < 0) {
                            console.log("Trading session has not started yet.")
                            queuedLoad()
                        } 
                        else {
                            const timeframeMs = chartTimeframeInSeconds * 1000; 
                            const numFullBars = Math.floor(elapsedTime / timeframeMs);
                            const candleStartTimeUTC = referenceStartTime + numFullBars*timeframeMs;
                            console.log("Candle Start Time UTC:", candleStartTimeUTC)
                            const lastBar = newCandleData[newCandleData.length - 1];
                            const lastBarTimeMs = ESTSecondstoUTCMillis(lastBar.time); 

                            const lastCompleteMinuteUTC = DateTime.fromMillis(now, {zone: 'utc'}).startOf('minute')
                            let minuteBarsEndTimeUTC = lastCompleteMinuteUTC.toMillis();
                            if(lastCompleteMinuteUTC.toMillis() <= candleStartTimeUTC) {
                                minuteBarsEndTimeUTC = candleStartTimeUTC;
                            }
                            const minuteBarsDurationMs = minuteBarsEndTimeUTC - candleStartTimeUTC;
                            console.log("minuteBarsDurationMs", minuteBarsDurationMs)
                            const numMinuteBars = Math.floor(minuteBarsDurationMs / (60*1000))
                            let minuteBarsPromise: Promise<BarData[]> = Promise.resolve([]);
                            console.log("numMinuteBars:", numMinuteBars)
                            if(numMinuteBars > 0) {
                                minuteBarsPromise = privateRequest<BarData[]>("getChartData", {
                                    securityId: inst.securityId,
                                    timeframe: "1",
                                    timestamp: candleStartTimeUTC,
                                    direction: "forward",
                                    bars: numMinuteBars, 
                                    extendedhours: inst.extendedHours, 
                                    isreplay: (get(replayInfo).status === "active" || get(replayInfo).status === "paused"),
                                });
                            }
                            const tickDataStartTimeUTC = minuteBarsEndTimeUTC; 
                            const tickDataDurationMs = UTCSecondstoESTSeconds(now/1000)*1000 - tickDataStartTimeUTC; 
                            let tickDataPromise: Promise<TradeData[]> = Promise.resolve([]);
                            if(tickDataDurationMs >0) {
                                tickDataPromise = privateRequest<TradeData[]>("getTradeData", {
                                    securityId: inst.securityId,
                                    time: tickDataStartTimeUTC, 
                                    lengthOfTime: tickDataDurationMs, 
                                    extendedHours: inst.extendedHours,
                                });
                            }
                            Promise.all([minuteBarsPromise, tickDataPromise]).then(([minuteBars, tickData]) => {
                                const allPrices: number[] = [];
                                if(minuteBars && minuteBars.length >0) {
                                    console.log(minuteBars)
                                    aggregateOpen = minuteBars[0].open;
                                    aggregateClose = minuteBars[minuteBars.length-1].close;
                                    minuteBars.forEach(bar => {
                                        allPrices.push(bar.high, bar.low)
                                    })
                                }
                                if(tickData && tickData.length > 0) {
                                    const filteredTickData = tickData.filter(tick => tick.size >= 100);

                                    if (filteredTickData.length > 0) {
                                        const tickPrices = filteredTickData.map(tick => tick.price);
                                        allPrices.push(...tickPrices);

                                        if (aggregateOpen === undefined) {
                                            aggregateOpen = tickPrices[0];
                                        }
                                        aggregateClose = tickPrices[tickPrices.length - 1];
                                    }
                                } 
                                if(allPrices.length > 0 && aggregateOpen !== undefined && aggregateClose !== undefined) {
                                    aggregateHigh = Math.max(...allPrices);
                                    aggregateLow = Math.min(...allPrices);
                                    console.log({
                                        time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                        open: aggregateOpen, 
                                        high: aggregateHigh,
                                        low: aggregateLow,
                                        close: aggregateClose,
                                    })
                                    if(candleStartTimeUTC > lastBarTimeMs) {
                                        newCandleData.push({
                                        time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                        open: aggregateOpen, 
                                        high: aggregateHigh,
                                        low: aggregateLow,
                                        close: aggregateClose,
                                        })
                                        console.log("push time", Date.now())
                                        if(queuedLoad) {
                                            queuedLoad()
                                        }
                                    }
                                    else {
                                        newCandleData[newCandleData.length-1] = {
                                        time: UTCSecondstoESTSeconds(candleStartTimeUTC /1000) as UTCTimestamp, 
                                        open: aggregateOpen, 
                                        high: aggregateHigh,
                                        low: aggregateLow,
                                        close: aggregateClose,
                                        }
                                        if(queuedLoad) {
                                            queuedLoad()
                                        }
                                    }
                                } 
                                else {
                                    console.log("No data returned for aggregation.")
                                    if(queuedLoad) {
                                        queuedLoad()
                                    }
                                }
                            }).catch(error => {
                                console.error("Error fetching data for aggregation:", error)
                            })
                        }
                    }
                }
                else { // REQUEST IS NOT FOR REAL TIME DATA // IT IS FOR BACK/FRONT LOAD HISTORICAL
                    //console.log("testing", chartCandleSeries.data()[chartCandleSeries.data().length-1].time)
                    queuedLoad = () => {
                        if (inst.direction == "forward") {
                            const visibleRange = chart.timeScale().getVisibleRange()
                            const vrFrom = visibleRange?.from as Time
                            const vrTo = visibleRange?.to as Time
                            chartCandleSeries.setData(newCandleData);
                            chartVolumeSeries.setData(newVolumeData);
                            chart.timeScale().setVisibleRange({from: vrFrom, to: vrTo})
                        }else if (inst.direction == "backward"){
                            chartCandleSeries.setData(newCandleData);
                            chartVolumeSeries.setData(newVolumeData);
                        }
                        queuedLoad = null
                        sma10Series.setData(calculateSMA(newCandleData, 10));
                        sma20Series.setData(calculateSMA(newCandleData, 20));
                        if (/^\d+$/.test(inst.timeframe)) {
                            vwapSeries.setData(calculateVWAP(newCandleData,newVolumeData));
                        }else{
                            vwapSeries.setData([])
                        }
                        if (inst.requestType == 'loadNewTicker') {
                            chart.timeScale().resetTimeScale()
                            //chart.timeScale().fitContent();
                            if (currentChartInstance.timestamp === 0){
                                chart.timeScale().applyOptions({
                                rightOffset: 10
                                });
                            }else{
                                chart.timeScale().applyOptions({
                                rightOffset: 0
                                });
                            }
                        }
                        isLoadingChartData = false; // Ensure this runs after data is loaded
                    }
                    if (inst.direction == "backward" || inst.requestType == "loadNewTicker"
                        || inst.direction == "forward" && !isPanning){
                            queuedLoad()
                            if(inst.requestType === "loadNewTicker" && !chartLatestDataReached 
                                && get(replayInfo).status === "inactive"){
                                backendLoadChartData({
                                    ...currentChartInstance,
                                    timestamp: ESTSecondstoUTCMillis(chartCandleSeries.data()[chartCandleSeries.data().length-1].time as UTCTimestamp) as UTCTimestamp,
                                    bars:  150, //+ 2*Math.floor(chart.getLogicalRange.to) - chartCandleSeries.data().length,
                                    direction: "forward",
                                    requestType: "loadAdditionalData",
                                    includeLastBar: true, 
                                })
                            }
                        }
                    }
                }) .catch((error: string) => {
                    console.error(error)

                    isLoadingChartData = false; // Ensure this runs after data is loaded
                });
    }