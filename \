package data
import (
    "fmt"
    "time"
)

type ActiveSecurity struct {
    securityId    int
	ticker        string
	cik           string
	figi          string
	activationDate time.Time
}
type god struct {
    ticker string
    cik string
    typ string
}
func writeSecurity(ActiveSecurity *ActiveSecurity, date time.Time) error {
    return nil
}
func initTickerDatabase(conn *Conn) {
	startDate := time.Date(2003, 9, 10, 0, 0, 0, 0, time.UTC) //need to pull from a record of last update, prolly in db
	currentDate := startDate
	activeSecuritiesRecord := make(map[string]ActiveSecurity)    // indexed by CIK or FIGI
    nextSecurityId := 1
	for currentDate.Before(time.Now()) {
		currentDateString := currentDate.Format("2006-01-02")
		polygonActiveSecurities := AllTickers(conn.Polygon, currentDateString)
        polygonActiveSecuritiesById := make(map[string]interface{}) //doesnt actually store a value besides the key so just use empty interface
        listings := 0
        delistings := 0
        tickerChanges := 0
        missed := 0
		for _, polySec := range polygonActiveSecurities {
            var securityId string
            if (polySec.CompositeFIGI != ""){
                securityId = polySec.CompositeFIGI
            //}else if (polySec.Type != "ETF" && polySec.Type != "" && polySec.CIK != ""){ //shit ass ident god
             //   fmt.Println("gid")
              //  continue
            }else{
                if (polySec.Type == "") {
                    fmt.Printf("missed etf %s \n", polySec.Ticker)
                }
                missed ++
                continue
            }
			if security, exists := activeSecuritiesRecord[securityId]; exists {
				if security.ticker != polySec.Ticker { //ticker change
                    fmt.Printf("ticker change: %s -> %s ID: %s\n", security.ticker, polySec.Ticker, securityId)
                    security.ticker = polySec.Ticker
                    writeSecurity(&security,currentDate)
                    activeSecuritiesRecord[securityId] = security //security is a copy so have to update the map 
                    tickerChanges ++
                }
			} else { //listing
                activeSecuritiesRecord[securityId] = ActiveSecurity{
                    securityId: nextSecurityId,
                    ticker:polySec.Ticker,
                    cik: polySec.CIK,
                    figi: polySec.CompositeFIGI,
                    activationDate: currentDate,
                }
                nextSecurityId ++
                listings ++
			}
            polygonActiveSecuritiesById[securityId] = struct{}{} //empty anonymous struct cause just use key to check existence not retrieve value
		}
    
        for securityId, security := range activeSecuritiesRecord {
            if _, exists := polygonActiveSecuritiesById[securityId]; !exists { //delisted
                delete(activeSecuritiesRecord, securityId)
                writeSecurity(&security, currentDate)
                fmt.Printf("delisting: %s\n", security.ticker)
                delistings ++
            }
        }
		currentDate = currentDate.AddDate(0, 0, 1)
        fmt.Printf("%d active securities, %d listings, %d delistings, %d ticker changes, %d missed, on %s ------------------------ \n",len(activeSecuritiesRecord),listings,delistings,tickerChanges,missed,currentDateString )
        var god string
        fmt.Scanf("%s", &god)
	}
}
